{"meta":{"title":"Jiavg","subtitle":"LYLG-JLC","description":"个人技术总结","author":"Jiavg","url":"https://lylgjiavg.github.io","root":"/"},"pages":[{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2019-06-29T15:25:35.750Z","comments":true,"path":"about/index.html","permalink":"https://lylgjiavg.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-09-30T09:25:30.000Z","updated":"2019-06-29T15:24:29.993Z","comments":true,"path":"categories/index.html","permalink":"https://lylgjiavg.github.io/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2018-12-12T13:25:30.000Z","updated":"2019-06-29T15:26:00.186Z","comments":true,"path":"friends/index.html","permalink":"https://lylgjiavg.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-30T10:23:38.000Z","updated":"2019-06-29T15:25:03.807Z","comments":true,"path":"tags/index.html","permalink":"https://lylgjiavg.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SpringBoot Cache初体验","slug":"SpringBoot缓存初体验","date":"2019-10-17T16:00:00.000Z","updated":"2019-10-18T15:49:31.480Z","comments":true,"path":"2019/10/18/SpringBoot缓存初体验/","link":"","permalink":"https://lylgjiavg.github.io/2019/10/18/SpringBoot缓存初体验/","excerpt":"","text":"SpringBoot Cache初体验一、JSR107 缓存规范​ Java Caching定义了5个核心接口，分别是CachingProvider, CacheManager, Cache, Entry 和 Expiry。 CachingProvider：定义了创建、配置、获取、管理和控制多个CacheManager。一个应用可以在运行期访问多个CachingProvider。 CacheManager：定义了创建、配置、获取、管理和控制多个唯一命名的Cache，这些Cache存在于CacheManager的上下文中。一个CacheManager仅被一个CachingProvider所拥有。 Cache：是一个类似Map的数据结构并临时存储以Key为索引的值。一个Cache仅被一个CacheManager所拥有。 Entry：是一个存储在Cache中的key-value对。 Expiry：每一个存储在Cache中的条目有一个定义的有效期。一旦超过这个时间，条目为过期的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过ExpiryPolicy设置。 二、Spring缓存抽象Spring从3.1开始定义了org.springframework.cache.Cache和org.springframework.cache.CacheManager接口来统一不同的缓存技术；并支持使用JCache（JSR-107）注解简化我们开发； Cache接口为缓存的组件规范定义，包含缓存的各种操作集合； Cache接口下Spring提供了各种xxxCache的实现；如RedisCache，EhCacheCache , ConcurrentMapCache等； ​ ​ 每次调用需要缓存功能的方法时，Spring会检查指定参数的指定的目标方法是否已经被调用过；如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户。下次调用直接从缓存中获取。 ​ 使用Spring缓存抽象时我们需要关注以下两点： 确定方法需要被缓存以及他们的缓存策略 从缓存中读取之前缓存存储的数据 三、重要概念&amp;缓存注解 Cache 缓存接口，定义缓存操作。实现有：RedisCache、EhCacheCache、ConcurrentMapCache等 CacheManager 缓存管理器，管理各种缓存（Cache）组件 @Cacheable 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存 @CacheEvict 清空缓存 @CachePut 保证方法被调用，又希望结果被缓存。 @EnableCaching 开启基于注解的缓存 keyGenerator 缓存数据时key生成策略 serialize 缓存数据时value序列化策略 @Cacheable/@CachePut/@CacheEvict主要的参数 Cache SpEL available metadata 四、缓存使用 引入spring-boot-starter-cache模块 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-cache&lt;/artifactId> &lt;/dependency> @EnableCaching开启缓存 @MapperScan(\"club.lylgjiang.cache.mapper\") @EnableCaching @SpringBootApplication public class SpringBootAdvancedApplication { public static void main(String[] args) { SpringApplication.run(SpringBootAdvancedApplication.class, args); } } 使用缓存注解 // Mapper层 public interface EmployeeMapper { @Select(\"SELECT * FROM employee WHERE id=#{id}\") public Employee selectEmpById(Integer id); } // Service层 @Service public class EmployeeService { @Autowired EmployeeMapper employeeMapper; // 添加缓存注解 @Cacheable(\"employee\") public Employee getEmpById(Integer id) { return employeeMapper.selectEmpById(id); } } // Controller层 @RestController public class EmpController { @Autowired EmployeeService employeeService; @GetMapping(\"/emp/{id}\") public Employee showEmployee(@PathVariable Integer id) { return employeeService.getEmpById(id); } } 其他设置： // 设置项目端口为80 server.port=80 // 设置springboot的club.lylgjiang.cache(mapper层在此包中)包下日志级别为debug logging.level.club.lylgjiang.cache=debug 验证： 在浏览器中输入http://localhost/emp/3 其中浏览器显示数据与控制台输出数据如下图所示： 刷新浏览器（F5）：控制台无变化，证明无响应的SQL语句执行，缓存成功。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://lylgjiavg.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://lylgjiavg.github.io/tags/SpringBoot/"},{"name":"Cache","slug":"Cache","permalink":"https://lylgjiavg.github.io/tags/Cache/"}]},{"title":"工厂方法模式","slug":"设计模式03","date":"2019-09-11T05:41:13.000Z","updated":"2019-09-11T06:37:01.606Z","comments":true,"path":"2019/09/11/设计模式03/","link":"","permalink":"https://lylgjiavg.github.io/2019/09/11/设计模式03/","excerpt":"","text":"工厂方法模式引言工厂，是用于生产商品的地方。现实生活中，一个人并不会自己生产铅笔、钢笔、毛笔，它会直接选择从工厂生产出来商品。 在面向对象的世界里，我们习惯于将各种事物进行抽象，将各种各样的对象进行组合以便实现我们的业务逻辑。而在组合过程中，我们需要自己来创建对象，工厂模式定义一个用于创建对象的接口，让子类决定实例化哪一个。这也是它是创建型设计模式的原因，用于创建对象。 模式的定义与特点工厂方法（FactoryMethod）模式的定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。 我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”，它不属于 GoF 的 23 种经典设计模式，它的缺点是增加新产品时会违背“开闭原则”。 本节介绍的“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。 工厂方法模式的主要优点有： 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程； 在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则； 其缺点是： 每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。 模式的结构与实现工厂方法模式由抽象工厂、具体工厂、抽象产品和具体产品等4个要素构成。本节来分析其基本结构和实现方法。 1. 模式的结构工厂方法模式的主要角色如下。 抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。 其结构图如下图所示: 在不了解工厂模式的情况下看到这个UML几乎是处于茫然状态，下面从不借助工厂模式到借助工厂模式的代码演进进行了解。 阶段1——强耦合，结构化ConcreteProduct product = new ConcreteProduct(); 在这个阶段并没有理解到面向对象编程的含义，代码的编写还是沿用结构化编程的方式，如果此时有另一个具体对象，则继续是单独写一个类而不会对两个类进行抽象。 ConcreteProduct product = new ConcreteProduct(); ConcreteProduct2 product2 = new ConcreteProduct2(); 阶段2——强耦合，OOP此时会对两个具体的产品的公共部分进行抽象为一个接口——Product。代码的编写演变到如下所示。 Product product = new ConcreteProduct(); 进行到这一阶段，你已经知道了面向对象的抽象威力，这能使你省去大量代码。 阶段3——松耦合，OOP上一个阶段我们利用了OOP的思想，但还是未能消除强耦合带来的问题，尽管直接new一个对象是很常见的一个动作，但在现如今的编码中，将控制权交由第三方来控制（IoC）能让代码耦合度更低，高内聚低耦合是软件编码过程中的黄金定律，耦合度更低的代码具有复用性更强，更容易测试，扩展性更好的特点。 Product product = Factory.createProduct('concreteProduct'); 在这段代码中使用的实际上是简单工厂模式，这和工厂方法模式有细微的区别，这里通过传入一个参数创建一个特定的实例对象（ConcreteProduct），这就是一种IoC思想——将创建对象（ConcreteProduct）的控制权交给了第三方（Factory），从而实现了对代码的解耦。 /** * 简单工厂模式 */ public class Factory { public static Product createProduct(String product) { switch (product) { case \"concreteProduct\": return new ConcreteProduct(); case \"concreteProduct2\": return new ConcreteProduct2(); default: return null; } } } 进行到这一步，我们代码已经改造得近乎完美，看似解决了耦合性问题，又利用OOP的思想。工厂模式似乎还并未派上用场，接下来问题马上就来。 此时，我们因为一个新的需求需要再创建一个新的Product实现类，首先当然我们能直接实现Product类——ConcreteProduct3，由于OOP的思想我们能直接复用。接下来要创建一个ConcreteProduct3对象，我们需要在原有的工厂类增加一个case判断语句。 /** * 简单工厂模式，新增case判断语句 */ public class Factory { public static Product createProduct(String product) { switch (product) { case \"concreteProduct\": return new ConcreteProduct(); case \"concreteProduct2\": return new ConcreteProduct2(); case \"concreteProcduct3\": return new ConcreteProduct3(); default: return null; } } } 再将传入方法的参数修改为”concreteProduct3”就能获取ConcreteProduct3实例对象。 注意上面的关键——需要在原有的工厂类上修改代码，代码扩展性的体现并不是修改原有代码来新增功能，而是新增代码就能扩展一个新功能。显然，上面的简单工厂模式没有满足这一点要求，因为它动了原有代码。 这个时候就该本文的主题工厂模式登场了。 工厂模式也有一个公共的工厂接口提供一个创建对象的工厂方法。 /** * 工厂模式，工厂接口 */ public interface IFactory { Product createProduct(); } 此时并没有唯一的工厂类，而是需要创建各个具体对象示例相应的工厂，例如ConcreteProductFactory。 /** * 工厂模式，具体工厂类 */ public class ConcreteProductFactory { public Product createProduct() { new ConcreteProduct(); } } 最初的Product product = new ConcreteProduct()就演变成了如下代码。 IFactory factory = new ConcreteProductFactory(); Product product = factory.createProduct(); 同样现在新增了一个具体对象，此时我们不必修改原有代码，只需要实现一个ConcreteProduct3Factory工 厂类返回ConcreteProduct实例对象即可。这是工厂模式和简单工厂模式最大的区别——不必在原有代码上进行修改，而是通过新增的方法扩展新的功能。 讲到这里，或许你有一个疑问在阶段2的时候你说直接new一个对象这会造成强耦合，所以在阶段3使用了IoC思想将创建对象的控制权交给了第三方，但是到最后的工厂模式IFactory factory = new ConcreteProductFactory()不也直接new了一个工厂实例对象吗？这不也产生了强耦合吗？这和直接new ConcreateProduct()到底有什么好处呢？并且好像只看到了代码的复杂度增高了，实际上也并未消除强耦合。 这里实际上产生了一种错觉，这个例子没有实际业务场景无法体会工厂设计模式所带来的优越感，当然它有缺点，它的缺点就是代码复杂度增加了，并且需要和具体类所对应的工厂强耦合。之所以造成一种错觉工厂设计模式不如直接new来得快，来得爽，正是因为这里所有的代码都是你一人写的，然而在实际开发过程中情况更为复杂并且通常是多人合作，多人合作提供给对方的往往是一个接口。也许Product接口是你写的，而具体实现类ConcreteProduct则是由他人写的，此时在其他人没有完成代码编写时你无法对它创建实例对象，然而利用工厂模式他人却能给你提供一个工厂返回一个接口。在实际编码中，往往来得快来得爽的代码大多都会埋下未知的隐患。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lylgjiavg.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lylgjiavg.github.io/tags/设计模式/"},{"name":"创建型模式","slug":"创建型模式","permalink":"https://lylgjiavg.github.io/tags/创建型模式/"}]},{"title":"GoF的23种设计模式","slug":"设计模式02","date":"2019-09-10T14:26:37.000Z","updated":"2019-09-10T15:30:59.929Z","comments":true,"path":"2019/09/10/设计模式02/","link":"","permalink":"https://lylgjiavg.github.io/2019/09/10/设计模式02/","excerpt":"","text":"前言 关于设计模式,笔者有话说:自大一学习C语言以来,直到大二上学期自学Java至今,虽然中间经历了磕磕绊绊,但也算是走到了今天,在这两年半的学习生涯中(狗头),一直致力于埋头苦敲代码。也认识到了自己学习的一些不足，虽然笔者前期跟随视频能理清一些业务逻辑，再到后来自己能够独立的完成类似功能的逻辑，并码出代码。但也深知自己的差距，并在最近有了学习设计模式的想法（还好这次意志力不这么坚定，没把学习的念头给压下去）。 笔者在学习Java基础教程时就接触到设计模式的相关概念,无奈当时代码量不够,无法体验出一个好的设计模式能够给项目带来的巨大好处。起始，最开始对项目的结构感觉到力不从心时并不是一开始着手于Java项目，这是因为我所联系的Java项目虽然业务量不少，但是整体的架构已经实现，自己只需要按层次开发就行，根据不同模块来进行开发。而让我真正感到力不从心的是今年暑假参加的一个3D建模大赛，此项目利用C#作为脚本语言进行开发，虽然此项目的代码量甚至不到以前写的项目的百分之一（确实如此），但自己来“设计”这个项目的整体架构，确实让我掉了不少头发（甚至我的Jiavg-1家族——刘海）也难以幸免。而在结束这个项目时，让我自己再来看这个项目时，真是一行都看不下去（可维护性为-1…）。 至此，我已深知设计模式的重要性，并参考了网上的一些视频教程和图文教程，但都感觉不是乏味难懂，就是觉得和实际开发中难以结合，不能体会设计模式的奥妙之处。直到我找寻了一位大佬的教程，他把设计模式深入到Java源码中去讲解，让我能够体会设计模式在实际开发中的作用。而自己接下来的教程中，我将会跟随大佬的脚步来慢慢体会设计模式的奥妙之处。当然，其中也必然穿插着一些理论性的概念及讲解（本文将参考C语言中文网的理论基础），因为这也是高层建筑的基础。 大佬的链接:https://patterns.coderbuff.com/ C语言中文网:http://c.biancheng.net/design_pattern/ 设计模式的分类和功能(安利一波理论基础)1. 根据目的来分 根据模式是用来完成什么工作来划分，这种方式可分为创建型模式、结构型模式和行为型模式 3 种。 创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。 结构型模式：用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。 行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。 2. 根据作用范围来分 根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种。 类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。 对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。 GoF的23种设计模式的功能前面说明了 GoF 的 23 种设计模式的分类，现在对各个模式的功能进行介绍。 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。 工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。 装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。 模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为. 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lylgjiavg.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lylgjiavg.github.io/tags/设计模式/"}]},{"title":"RabbitMQ-死信队列","slug":"RabbitMQ12","date":"2019-09-10T07:20:02.000Z","updated":"2019-09-10T08:10:31.962Z","comments":true,"path":"2019/09/10/RabbitMQ12/","link":"","permalink":"https://lylgjiavg.github.io/2019/09/10/RabbitMQ12/","excerpt":"","text":"死信队列 利用DLX,当消息在一个队列中变成死信(dead message)之后,他能够被重新publish到另一个Exchange,这个Exchange就是DLX. 消息变成死信有以下几种情况 消息被拒绝(basic.reject/basic.nack)并且requeue=false 消息TTL过期 队列到达最大长度 死信队列特点 DLX也是一个正常的Exchange,和一般的Exchange没有区别,它能在任何的队列上被指定,实际上就是设置某个队列的属性. 当这个队列中有死信时,RabbitMQ就会自动将这个消息重新发布到设置的这个Exchange上去,进而被路由到另一个队列. 可以监听这个队列中消息做相应的处理,这个特性可以弥补RabbitMQ3.0以前支持的immediate参数的功能. 死信队列设置 首先需要设置死信队列的exchange和queue,然后进行绑定;例: Exchange:dlx.exchange Queue:dlx.queue RoutingKey:# 然后我们进行正常声明交换机、队列、绑定，只不过我们需要在队列上加一个参数即可:arguments.put(“x-dead-letter-exchange”, “dlx.exchange”); 这样消息在过期、requeue、队列在到达最大长度时，消息就可以直接路由到死信队列！ 死信队列实现 import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import lylgjiavg.step02.limit.MyConsumer; import java.util.HashMap; import java.util.Map; /** * @Classname Consumer * @Description 死信队列：消费端 * @Date 2019/9/10 15:48 * @Created by Jiavg */ public class Consumer { public static void main(String[] args) throws Exception{ ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(\"127.0.0.1\"); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(\"/\"); connectionFactory.setUsername(\"guest\"); connectionFactory.setPassword(\"guest\"); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchangeName = \"test_DLX_Exchange\"; String routingKey = \"DLX.save\"; String queueName = \"test_DLX_Queue\"; channel.exchangeDeclare(exchangeName, \"topic\", true, false, null); Map&lt;String, Object> arguments = new HashMap&lt;>(); arguments.put(\"x-dead-letter-exchange\", \"dlx.exchange\"); // 这个arguments属性要设置到声明队列上 channel.queueDeclare(queueName, true,false,false, arguments); channel.queueBind(queueName, exchangeName, routingKey); // 要进行死信队列的声明 channel.exchangeDeclare(\"dlx.exchange\", \"topic\", true, false, null); channel.queueDeclare(\"dlx.queue\", true, false, false, null); channel.queueBind(\"dlx.queue\", \"dlx.exchange\", \"#\"); channel.basicConsume(queueName, true, new MyConsumer(channel)); } }","categories":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://lylgjiavg.github.io/categories/消息中间件/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://lylgjiavg.github.io/tags/RabbitMQ/"},{"name":"消息中间件","slug":"消息中间件","permalink":"https://lylgjiavg.github.io/tags/消息中间件/"}]},{"title":"RabbitMQ-TTL队列/消息","slug":"RabbitMQ11","date":"2019-09-10T06:26:07.000Z","updated":"2019-09-10T07:21:25.856Z","comments":true,"path":"2019/09/10/RabbitMQ11/","link":"","permalink":"https://lylgjiavg.github.io/2019/09/10/RabbitMQ11/","excerpt":"","text":"RabbitMQ之TTL队列/消息 TTL是Time To Live的缩写,也就是生存时间. RabbitMQ支持消息的过期时间,在消息发送时可以进行制定. RabbitMQ支持队列的过期时间,从消息入队列开始计算,只要超过了队列的超时时间配置,那么消息会自动的清除. TTL队列 在设置队列的超时时间有两种方式,一是:通过Java代码声明队列时设置其超时时间设置;二是:通过RabbitMQ管控台的可视化操作下声明队列并进行设置其超时时间参数配置. TTL队列声明方式一:声明队列并设置其TTL import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import com.rabbitmq.client.QueueingConsumer; import java.util.HashMap; import java.util.Map; /** * @Classname Consumer * @Description TTL队列/消息：消费者 * @Date 2019/9/10 14:36 * @Created by Jiavg */ public class Consumer { public static void main(String[] args) throws Exception{ ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(\"127.0.0.1\"); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(\"/\"); connectionFactory.setUsername(\"guest\"); connectionFactory.setPassword(\"guest\"); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchangeName = \"test_TTL_Exchange\"; String routingKey = \"TTL.#\"; String queueName = \"test_TTL_Queue\"; // 创建声明队列所用到的参数集合,并设置其超时时间x-message-ttl为10000(10秒) Map&lt;String, Object> arguments = new HashMap&lt;>(); arguments.put(\"x-message-ttl\", 10000); // 声明交换机、声明队列、绑定队列到交换机 channel.exchangeDeclare(exchangeName, \"topic\", true, false, null); channel.queueDeclare(queueName, true, false, false, arguments); channel.queueBind(queueName, exchangeName, routingKey); QueueingConsumer queueingConsumer = new QueueingConsumer(channel); channel.basicConsume(queueName, true, queueingConsumer); while (true) { QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery(); byte[] body = delivery.getBody(); System.out.printf(\"消费端:\" + new String(body)); } } } 管控台变化-超时队列信息超时队列相关信息 验证超时队列在管控台发送一条消息 信息处理过程 由上图可知,超时队列test_TTL_Queue中的消息在经过指定时间后会自动清除 TTL队列声明方式二:声明队列并设置其TTL TTL消息 在设置消息的超时时间有两种方式,一是:通过Java代码发送消息时设置其超时时间设置;二是:通过RabbitMQ管控台的可视化操作下发送消息并进行设置其超时时间参数配置(了解). TTL消息声明方式一:声明消息并设置其TTL import com.rabbitmq.client.*; import java.io.IOException; /** * @Classname Producer * @Description TTL队列/消息：生产者 * @Date 2019/9/10 14:38 * @Created by Jiavg */ public class Producer { public static void main(String[] args) throws Exception{ ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(\"127.0.0.1\"); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(\"/\"); connectionFactory.setUsername(\"guest\"); connectionFactory.setPassword(\"guest\"); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchangeName = \"test_Topic_Exchange\"; String routingKey = \"test.ttl\"; String msg = \"Hello World send TTL Message\"; AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder() .deliveryMode(2) .contentEncoding(\"UTF-8\") // 设置消息的超时时间 .expiration(\"10000\") .build(); channel.basicPublish(exchangeName, routingKey, properties, msg.getBytes()); } } 验证超时消息信息处理过程 由上图可知,设置了超时时间的消息在经过指定时间后会被自动清除. TTL消息声明方式二:声明消息并设置其TTL","categories":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://lylgjiavg.github.io/categories/消息中间件/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://lylgjiavg.github.io/tags/RabbitMQ/"},{"name":"消息中间件","slug":"消息中间件","permalink":"https://lylgjiavg.github.io/tags/消息中间件/"}]},{"title":"RabbitMQ-消费端ACK与重回队列","slug":"RabbitMQ10","date":"2019-09-09T12:27:02.000Z","updated":"2019-09-09T13:52:13.645Z","comments":true,"path":"2019/09/09/RabbitMQ10/","link":"","permalink":"https://lylgjiavg.github.io/2019/09/09/RabbitMQ10/","excerpt":"","text":"RabbitMQ的消费端ACK与重回队列消费端的手工ACK和NACK 消费端进行消费的时候,如果由于业务异常我们可以进行日志的记录,然后进行补偿. 如果由于服务器宕机等严重问题,那么我们就需要手工进行ACK保障消费端消费成功. 消费端的重回队列 消费端重回队列是为了对没有处理成功的消息,把消息重新传递给Broker. 一般我们在实际应用中,都会关闭重回队列,也就是设置为false. 消费端ACK与重回队列代码演示消费端自定义监听 import com.rabbitmq.client.AMQP; import com.rabbitmq.client.Channel; import com.rabbitmq.client.DefaultConsumer; import com.rabbitmq.client.Envelope; import java.io.IOException; /** * @Classname MyConsumer * @Description 消费端ACK:自定义客户端监听 * @Date 2019/9/8 13:15 * @Created by Jiavg */ public class MyConsumer extends DefaultConsumer { private Channel channel; /** * Constructs a new instance and records its association to the passed-in channel. * @param channel the channel to which this consumer is attached */ public MyConsumer(Channel channel) { super(channel); this.channel = channel; } @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(\"body:\" + new String(body)); // 延时ack try { Thread.sleep(10000); } catch (InterruptedException e) { e.printStackTrace(); } if((Integer)properties.getHeaders().get(\"num\") == 1){ // basicNack(long deliveryTag, boolean multiple, boolean requeue); channel.basicNack(envelope.getDeliveryTag(), false, true); }else { // basicAck(long deliveryTag, boolean multiple) throws IOException; channel.basicAck(envelope.getDeliveryTag(), false); } } } 注意: 在自定义消费端监听处理消息的handleDelivery()方法中,我们使用Thread.sleep(10000);延时10以方便我们能够详细的看到消息的消费状况. 在处理消息中,我们通过判断消息的properties中的headers配置参数中的num来决定此条消息是进行Ack确认还是进行NAck进行重回队列(requeue设置为true). 消费端实现 import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; /** * @Classname Consumer * @Description 消费端ACK：消费端 * @Date 2019/9/8 10:48 * @Created by Jiavg */ public class Consumer { public static void main(String[] args) throws Exception{ ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(\"127.0.0.1\"); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(\"/\"); connectionFactory.setUsername(\"guest\"); connectionFactory.setPassword(\"guest\"); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchangeName = \"test_Ack_Exchange\"; String routingKey = \"Ack.#\"; String queueName = \"test_Ack_Queue\"; // 声明交换机、声明队列、绑定队列到交换机 channel.exchangeDeclare(exchangeName, \"topic\", true, false, null); channel.queueDeclare(queueName, true, false, false, null); channel.queueBind(queueName, exchangeName, routingKey); // autoAck设置为false channel.basicConsume(queueName, false, new MyConsumer(channel)); } } 消费端运行-管控台变化交换机变化 交换机绑定情况 生产端实现 import com.rabbitmq.client.AMQP; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import java.util.HashMap; import java.util.Map; /** * @Classname Producer * @Description 消费端ACK：生产者 * @Date 2019/9/8 10:50 * @Created by Jiavg */ public class Producer { public static void main(String[] args) throws Exception{ ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(\"127.0.0.1\"); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(\"/\"); connectionFactory.setUsername(\"guest\"); connectionFactory.setPassword(\"guest\"); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchangeName = \"test_Ack_Exchange\"; String routingKey = \"Ack.save\"; for (int i = 0; i &lt; 4; i++){ String msg = \"Hello World send Ack Message:\" + i; Map&lt;String, Object> headers = new HashMap&lt;>(); headers.put(\"num\", i); AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder() .deliveryMode(2) .contentEncoding(\"UTF-8\") .headers(headers) .build(); channel.basicPublish(exchangeName, routingKey,true, properties, msg.getBytes()); } } } 注意:投递模式deliveryMode设置为2,为就是将消息设置为持久化的，此时rabbitmq就会将消息持久化到磁盘上去(要使此模式生效,相应队列也应设置为持久化). 生产端运行-管控台和控制台变化管控台变化 控制台变化 由图结合自定义消费端监听可知,在发送的四条消息中,有一条消息被消费端NAck,故在队列中一直有一条消息未被ack.并且此条消息由于requeue设置为true,故此条消息被反复重回给队列并被此队列反复投递给此消费端(由于此队列只绑定了一个消费端).","categories":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://lylgjiavg.github.io/categories/消息中间件/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://lylgjiavg.github.io/tags/RabbitMQ/"},{"name":"消息中间件","slug":"消息中间件","permalink":"https://lylgjiavg.github.io/tags/消息中间件/"}]},{"title":"RabbitMQ-消费端自定义监听","slug":"RabbitMQ08-1","date":"2019-09-09T07:54:16.000Z","updated":"2019-09-09T08:40:02.826Z","comments":true,"path":"2019/09/09/RabbitMQ08-1/","link":"","permalink":"https://lylgjiavg.github.io/2019/09/09/RabbitMQ08-1/","excerpt":"","text":"消费端自定义监听 我们一般就是在代码中编写while循环,进行consumer.nextDelivery()方法进行获取下一条消息,然后进行消费处理. 但是我们使用自定义的Consumer更加的方便,解耦性更加的强,也是在实际工作中最常用的使用方式! 实现消费端自定义监听的两种方式实现com.rabbitmq.client.Consumer接口 import java.io.IOException; /** * Interface for application callback objects to receive notifications and messages from * a queue by subscription. * Most implementations will subclass {@link DefaultConsumer}. * &lt;p/> * The methods of this interface are invoked in a dispatch * thread which is separate from the {@link Connection}'s thread. This * allows {@link Consumer}s to call {@link Channel} or {@link * Connection} methods without causing a deadlock. * &lt;p/> * The {@link Consumer}s on a particular {@link Channel} are invoked serially on one or more * dispatch threads. {@link Consumer}s should avoid executing long-running code * because this will delay dispatch of messages to other {@link Consumer}s on the same * {@link Channel}. * * @see Channel#basicConsume(String, boolean, String, boolean, boolean, java.util.Map, Consumer) * @see Channel#basicCancel */ public interface Consumer { /** * Called when the consumer is registered by a call to any of the * {@link Channel#basicConsume} methods. * @param consumerTag the &lt;i>consumer tag&lt;/i> associated with the consumer */ void handleConsumeOk(String consumerTag); /** * Called when the consumer is cancelled by a call to {@link Channel#basicCancel}. * @param consumerTag the &lt;i>consumer tag&lt;/i> associated with the consumer */ void handleCancelOk(String consumerTag); /** * Called when the consumer is cancelled for reasons &lt;i>other than&lt;/i> by a call to * {@link Channel#basicCancel}. For example, the queue has been deleted. * See {@link #handleCancelOk} for notification of consumer * cancellation due to {@link Channel#basicCancel}. * @param consumerTag the &lt;i>consumer tag&lt;/i> associated with the consumer * @throws IOException */ void handleCancel(String consumerTag) throws IOException; /** * Called when either the channel or the underlying connection has been shut down. * @param consumerTag the &lt;i>consumer tag&lt;/i> associated with the consumer * @param sig a {@link ShutdownSignalException} indicating the reason for the shut down */ void handleShutdownSignal(String consumerTag, ShutdownSignalException sig); /** * Called when a &lt;code>&lt;b>basic.recover-ok&lt;/b>&lt;/code> is received * in reply to a &lt;code>&lt;b>basic.recover&lt;/b>&lt;/code>. All messages * received before this is invoked that haven't been &lt;i>ack&lt;/i>'ed will be * re-delivered. All messages received afterwards won't be. * @param consumerTag the &lt;i>consumer tag&lt;/i> associated with the consumer */ void handleRecoverOk(String consumerTag); /** * Called when a &lt;code>&lt;b>basic.deliver&lt;/b>&lt;/code> is received for this consumer. * @param consumerTag the &lt;i>consumer tag&lt;/i> associated with the consumer * @param envelope packaging data for the message * @param properties content header data for the message * @param body the message body (opaque, client-specific byte array) * @throws IOException if the consumer encounters an I/O error while processing the message * @see Envelope */ void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException; } 继承com.rabbitmq.client.DefaultConsumer类 import java.io.IOException; /** * Convenience class providing a default implementation of {@link Consumer}. * We anticipate that most Consumer implementations will subclass this class. */ public class DefaultConsumer implements Consumer { /** Channel that this consumer is associated with. */ private final Channel _channel; /** Consumer tag for this consumer. */ private volatile String _consumerTag; /** * Constructs a new instance and records its association to the passed-in channel. * @param channel the channel to which this consumer is attached */ public DefaultConsumer(Channel channel) { _channel = channel; } /** * Stores the most recently passed-in consumerTag - semantically, there should be only one. * @see Consumer#handleConsumeOk */ public void handleConsumeOk(String consumerTag) { this._consumerTag = consumerTag; } /** * No-op implementation of {@link Consumer#handleCancelOk}. * @param consumerTag the defined consumer tag (client- or server-generated) */ public void handleCancelOk(String consumerTag) { // no work to do } /** * No-op implementation of {@link Consumer#handleCancel(String)} * @param consumerTag the defined consumer tag (client- or server-generated) */ public void handleCancel(String consumerTag) throws IOException { // no work to do } /** * No-op implementation of {@link Consumer#handleShutdownSignal}. */ public void handleShutdownSignal(String consumerTag, ShutdownSignalException sig) { // no work to do } /** * No-op implementation of {@link Consumer#handleRecoverOk}. */ public void handleRecoverOk(String consumerTag) { // no work to do } /** * No-op implementation of {@link Consumer#handleDelivery}. */ public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { // no work to do } /** * Retrieve the channel. * @return the channel this consumer is attached to. */ public Channel getChannel() { return _channel; } /** * Retrieve the consumer tag. * @return the most recently notified consumer tag. */ public String getConsumerTag() { return _consumerTag; } } 消费端自定义监听代码演示消费端自定义监听 import com.rabbitmq.client.*; import java.io.IOException; /** * @Classname MyConsumer * @Description 自定义消费端 * @Date 2019/9/9 16:03 * @Created by Jiavg */ public class MyConsumer extends DefaultConsumer { private Channel channel; /** * Constructs a new instance and records its association to the passed-in channel. * @param channel the channel to which this consumer is attached */ public MyConsumer(Channel channel) { super(channel); this.channel = channel; } @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { // super.handleDelivery(consumerTag, envelope, properties, body); System.out.println(\"consumerTag:\" + consumerTag + \"--此条消息已处理\"); System.out.println(\"\\t消息内容:\" + new String(body)); channel.basicAck(envelope.getDeliveryTag(), false); } } 消费端代码实现 import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; /** * @Classname Consumer * @Description 消费端自定义监听：消费端 * @Date 2019/9/8 10:48 * @Created by Jiavg */ public class Consumer { public static void main(String[] args) throws Exception{ ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(\"127.0.0.1\"); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(\"/\"); connectionFactory.setUsername(\"guest\"); connectionFactory.setPassword(\"guest\"); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchangeName = \"test_Custom_Exchange\"; String routingKey = \"Custom.#\"; String queueName = \"test_Custom_Queue\"; // 声明交换机、声明队列、绑定队列到交换机 channel.exchangeDeclare(exchangeName, \"topic\", true, false, null); channel.queueDeclare(queueName, true, false, false, null); channel.queueBind(queueName, exchangeName, routingKey); MyConsumer myConsumer = new MyConsumer(channel); channel.basicConsume(queueName, false, myConsumer); } } 生产端代码实现 import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; /** * @Classname Producer * @Description 消费端自定义监听：生产端 * @Date 2019/9/8 10:50 * @Created by Jiavg */ public class Producer { public static void main(String[] args) throws Exception{ ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(\"127.0.0.1\"); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(\"/\"); connectionFactory.setUsername(\"guest\"); connectionFactory.setPassword(\"guest\"); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchangeName = \"test_Custom_Exchange\"; String routingKey = \"Custom.save\"; String msg = \"Hello World send Custom Message\"; for (int i = 0; i &lt; 4; i++){ channel.basicPublish(exchangeName, routingKey, null, msg.getBytes()); } } } 消费端控制台变换","categories":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://lylgjiavg.github.io/categories/消息中间件/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://lylgjiavg.github.io/tags/RabbitMQ/"},{"name":"消息中间件","slug":"消息中间件","permalink":"https://lylgjiavg.github.io/tags/消息中间件/"}]},{"title":"RabbitMQ-消费端限流","slug":"RabbitMQ09","date":"2019-09-08T04:33:11.000Z","updated":"2019-09-08T06:22:57.820Z","comments":true,"path":"2019/09/08/RabbitMQ09/","link":"","permalink":"https://lylgjiavg.github.io/2019/09/08/RabbitMQ09/","excerpt":"","text":"消费端限流什么是消费端限流 假设一个场景,首先,我们RabbitMQ服务器上有上万条为处理的消息,我们随便打开一个消费者客户端,会出现下面的情况: 巨量的消息瞬间全部推送过来,但是我们的单个客户端无法同时处理这么多数据,造成客户端宕机! RabbitMQ消费端限流机制 RabbitMQ提供了一种QoS(服务质量保证)功能,即在非自动确认消息的前提下,如果一定数目的消息(通过基于Consume或者Channel设置的QoS值)未被确认前,不进行消费新的消息. void basicQos(int prefetchSize, int prefetchCount, boolean global) throws IOException; prefetchSize: 服务器将交付的最大内容量(以八进制为单位度量)，如果没有限制，则设置为0 prefetchCount: 会告诉RabbitMQ不要同时给一个消费者推送多于prefetchCount个消息,即一旦有prefetchCount个消息未ack,则该Consumer将block掉,直到有消息ack. global:true/false是否将上面的设置应用于Channel;简单点说,就是上面限制是Channel级别还是Consumer级别. prefetchSize和global这两项,RabbitMQ没有实现,暂且不研究prefetchCount在no_ack=false的情况下生效,即在自动应答的情况下这两个值是不生效的. RabbitMQ消费端限流代码演示自定义消费者 import com.rabbitmq.client.AMQP; import com.rabbitmq.client.Channel; import com.rabbitmq.client.DefaultConsumer; import com.rabbitmq.client.Envelope; import java.io.IOException; /** * @Classname MyConsumer * @Description TODO * @Date 2019/9/8 13:15 * @Created by Jiavg */ public class MyConsumer extends DefaultConsumer { /** * Constructs a new instance and records its association to the passed-in channel. * @param channel the channel to which this consumer is attached */ public MyConsumer(Channel channel) { super(channel); this.channel = channel; } private Channel channel; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(\"---------consume message---------\"); System.out.println(\"consumerTag:\" + consumerTag); System.out.println(\"envelope:\" + envelope); System.out.println(\"properties:\" + properties); System.out.println(\"body:\" + new String(body)); // 延时ack,便于演示消费端限流 try { Thread.sleep(10000); } catch (InterruptedException e) { e.printStackTrace(); } channel.basicAck(envelope.getDeliveryTag(), false); } } 消费端代码 import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; /** * @Classname Consumer * @Description 消费端限流：消费者 * @Date 2019/9/8 10:48 * @Created by Jiavg */ public class Consumer { public static void main(String[] args) throws Exception{ ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(\"127.0.0.1\"); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(\"/\"); connectionFactory.setUsername(\"guest\"); connectionFactory.setPassword(\"guest\"); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchangeName = \"test_QoS_Exchange\"; String routingKey = \"QoS.#\"; String queueName = \"test_QoS_Queue\"; // 声明交换机、声明队列、绑定队列到交换机 channel.exchangeDeclare(exchangeName, \"topic\", true, false, null); channel.queueDeclare(queueName, true, false, false, null); channel.queueBind(queueName, exchangeName, routingKey); // 限流方式 channel.basicQos(0, 1, false); // autoAck设置为false channel.basicConsume(queueName, false, new MyConsumer(channel)); } } 启动消费端-管控台变化 交换机变化 交换机绑定情况 生产端代码 import com.rabbitmq.client.*; /** * @Classname Producer * @Description 消费端限流：生产者 * @Date 2019/9/8 10:50 * @Created by Jiavg */ public class Producer { public static void main(String[] args) throws Exception{ ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(\"127.0.0.1\"); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(\"/\"); connectionFactory.setUsername(\"guest\"); connectionFactory.setPassword(\"guest\"); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchangeName = \"test_QoS_Exchange\"; String routingKey = \"QoS.save\"; String msg = \"Hello World send QoS Message\"; for (int i = 0; i &lt; 4; i++){ channel.basicPublish(exchangeName, routingKey, null, msg.getBytes()); } } } 生产端运行-管控台变化 Overview页面变化 由图可知,由于我们自定义消费者在处理消息的方法中(handleDelivery),使用Thread.sleep(10000);延迟10秒ack,故在Overview页面显示每10秒才会消费一条消息(只有在Broker接收到消费端的ack才会发送下一条消息).","categories":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://lylgjiavg.github.io/categories/消息中间件/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://lylgjiavg.github.io/tags/RabbitMQ/"},{"name":"消息中间件","slug":"消息中间件","permalink":"https://lylgjiavg.github.io/tags/消息中间件/"}]},{"title":"RabbitMQ-Return消息机制","slug":"RabbitMQ08","date":"2019-09-08T02:28:53.000Z","updated":"2019-09-08T03:42:59.636Z","comments":true,"path":"2019/09/08/RabbitMQ08/","link":"","permalink":"https://lylgjiavg.github.io/2019/09/08/RabbitMQ08/","excerpt":"","text":"RabbitMQ的Return消息机制Return消息机制的作用 Return Listener用于处理一些不可路由的消息. 我们的消息生产者,通过指定一个Exchange和RoutingKey,把消息送达到某一个队列中去,然后我们的消费者监听队列,进行消费处理操作. 但是在某些情况下,如果我们发送息的时消候,当前的Exchange不存在或者指定的路由Key路由不到,这个时候如果我们需要监听这种不可到达的消息,就需要使用Return Listener. 启用Return消息机制的关键配置 在基础API中有一个关键的配置项:Mandatory:如果为true,则监听器会接收到路由不可到达的消息,然后进行后续处理;如果为false,那么broker端会自动删除该消息. Return消息机制流程 Return消息机制流程图如下所示: Return消息机制代码演示消费端实现消费者代码 import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import com.rabbitmq.client.QueueingConsumer; /** * @Classname Consumer * @Description Return消息机制：消费者 * @Date 2019/9/8 10:48 * @Created by Jiavg */ public class Consumer { public static void main(String[] args) throws Exception{ ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(\"127.0.0.1\"); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(\"/\"); connectionFactory.setUsername(\"guest\"); connectionFactory.setPassword(\"guest\"); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchangeName = \"test_Return_Exchange\"; String routingKey = \"return.#\"; String queueName = \"test_Return_Queue\"; // 声明交换机、声明队列、绑定队列到交换机 channel.exchangeDeclare(exchangeName, \"topic\", true, false, null); channel.queueDeclare(queueName, true, false, false, null); channel.queueBind(queueName, exchangeName, routingKey); // 创建消费者、消费队列 QueueingConsumer queueingConsumer = new QueueingConsumer(channel); channel.basicConsume(queueName, true, queueingConsumer); while (true) { QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery(); byte[] body = delivery.getBody(); System.out.printf(\"消费端:\" + new String(body)); } } } 启动消费端-管控台变化 交换机变化 交换机绑定情况 注意:此交换机与队列绑定的路由Key我们在生产者端时并不遵守此路由key,即让消息无法正确路由,以触发ReturnListener. 生产端实现生产者代码 import com.rabbitmq.client.*; import java.io.IOException; /** * @Classname Producer * @Description Return消息机制：生产者 * @Date 2019/9/8 10:50 * @Created by Jiavg */ public class Producer { public static void main(String[] args) throws Exception{ ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(\"127.0.0.1\"); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(\"/\"); connectionFactory.setUsername(\"guest\"); connectionFactory.setPassword(\"guest\"); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchangeName = \"test_Return_Exchange\"; String routingKey = \"unReturn.save\"; String msg = \"Hello World send Return Message\"; // 添加一个Return监听 channel.addReturnListener(new ReturnListener() { @Override public void handleReturn(int replyCode, String replyText, String exchange, String routingKey, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(\"----------handle return-----------\"); System.out.println(\"replyCode:\" + replyCode); System.out.println(\"replyText:\" + replyText); System.out.println(\"exchange:\" + exchange); System.out.println(\"routingKey:\" + routingKey); System.out.println(\"properties:\" + properties); System.out.println(\"body:\" + new String(body)); } }); // 发送消息:第三个参数mandatory:true,默认为false channel.basicPublish(exchangeName, routingKey, true, null, msg.getBytes()); } } 注意:消息的路由key我们设置为unReturn.save,在相应交换机上并没有符合此路由key的队列,此条消息将无法正确路由到队列上. 启动生产端-管控台变化 Overview页面变化 由上图可知,虽然RabbitMQ接收到了一条消息(Message rates发生变化),但是并没有被路由到正确队列中(Queued messages的Total为0). 生产者控制台变化 可见,由于消息无法正确路由到相应的队列中,触发了Return Listener监听器(打印了相应的信息). 注意:要使RabbitMQ回送给生产者无法路由的消息,在生产者端basicPublish(String exchange, StringroutingKey, boolean mandatory, BasicProperties props, byte[] body) throws IOException;的mandatory要设置为true,否则Broker端默认会自动删除该消息.","categories":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://lylgjiavg.github.io/categories/消息中间件/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://lylgjiavg.github.io/tags/RabbitMQ/"},{"name":"消息中间件","slug":"消息中间件","permalink":"https://lylgjiavg.github.io/tags/消息中间件/"}]},{"title":"RabbitMQ-Confirm确认消息","slug":"RabbitMQ07","date":"2019-09-07T02:10:12.000Z","updated":"2019-09-07T03:57:31.620Z","comments":true,"path":"2019/09/07/RabbitMQ07/","link":"","permalink":"https://lylgjiavg.github.io/2019/09/07/RabbitMQ07/","excerpt":"","text":"Confirm消息确认机制 消息的确认,是指生产者投递消息后,如果Broker接收到消息,则会给我们生产者一个应答. 生产者进行接收应答,用来确认这条消息是否正常的发送到Broker,这种方式也是消息的可靠性投递的核心保障. Confirm确认消息流程解析 确认机制流程图 如何实现Confirm确认消息? Step1:在channel上开启确认模式:channel.confirmSelect(); Step2:在Channel上添加监听:addConfirmListener,监听成功和失败的返回结果,根据具体的结果对消息进行重新发送、或记录日志等后续处理。 Confirm确认消息代码演示消费者实现消费者代码 import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import com.rabbitmq.client.QueueingConsumer; /** * @Classname Consumer * @Description Confirm确认机制：消费者 * @Date 2019/9/7 10:48 * @Created by Jiavg */ public class Consumer { public static void main(String[] args) throws Exception{ ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(\"127.0.0.1\"); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(\"/\"); connectionFactory.setUsername(\"guest\"); connectionFactory.setPassword(\"guest\"); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchangeName = \"test_Confirm_Exchange\"; String routingKey = \"confirm.#\"; String queueName = \"test_Confirm_Queue\"; // 声明交换机、声明队列、绑定队列到交换机 channel.exchangeDeclare(exchangeName, \"topic\", true, false, null); channel.queueDeclare(queueName, true, false, false, null); channel.queueBind(queueName, exchangeName, routingKey); // 创建消费者、消费队列 QueueingConsumer queueingConsumer = new QueueingConsumer(channel); channel.basicConsume(queueName, true, queueingConsumer); while (true) { QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery(); byte[] body = delivery.getBody(); System.out.printf(\"消费端:\" + new String(body)); } } } 消费者运行-管控台变化 新增对应交换机 新增对应队列 队列绑定关系 生产者实现生产者代码 import com.rabbitmq.client.Channel; import com.rabbitmq.client.ConfirmListener; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import java.io.IOException; /** * @Classname Producer * @Description Confirm确认机制：生产者 * @Date 2019/9/7 10:42 * @Created by Jiavg */ public class Producer { public static void main(String[] args) throws Exception{ ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(\"127.0.0.1\"); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(\"/\"); connectionFactory.setUsername(\"guest\"); connectionFactory.setPassword(\"guest\"); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); // 指定消息投递模式:消息的确认模式 channel.confirmSelect(); String exchangeName = \"test_Confirm_Exchange\"; String routingKey = \"confirm.save\"; String msg = \"Hello World send Confirm Message\"; // 发送消息 channel.basicPublish(exchangeName, routingKey, null, msg.getBytes()); // 添加一个确认监听 channel.addConfirmListener(new ConfirmListener() { @Override public void handleAck(long deliveryTag, boolean multiple) throws IOException { System.out.printf(\"-------Ack-------\"); } @Override public void handleNack(long deliveryTag, boolean multiple) throws IOException { System.out.printf(\"------No Ack-----\"); } }); } } 生产者运行-控制台变化 消费端接收到监听队列的消息. 生产端的确认监听方法打印出相应信息. 注意事项Point1 Confirm确认机制是生产者和Broker(RabbitMQ)之间的确认机制,不涉及到消费者是否消费了此条消息.为了更好的理解,我们进行了如下实验: 紧接着上面的实验:我们关闭消费者端,并重新运行生产者端: 管控台变化 通过上图我们可以看出由于关闭了消费者端,该条信息并未被消费,故存留在RabbitMQ的队列中. 生产者控制台变化 通过上图可以看出,Broker给生产者发送了Ack消息确认.由此可见,只要是Broker正确的接收到消息就会给生产端发送Ack确认,而不管消费端是否正常消费了此条消息. Point2 Confirm确认机制是生产者和Broker(RabbitMQ)之间的确认机制,甚至Broker没有将此消息正确路由到对应的队列时,还是会给生产者端发送Ack确认.为了更好的理解,我们进行了如下实验: 紧接着上面的实验,我们修改生产者的发送消息的路由键为”unConfirm.save”(此时RabbitMQ中并没有对应的队列),此时我们运行生产端. 管控台变化 通过上图我们可以看出由于修改了生产者的消息的路由键,此时虽然Message Rates虽然发生改变(Broker接收到消息),但是并没有将此条消息正确的路由到对应的队列中(Queued Messages的总消息数量没有发生改变). 生产者控制台变化 通过上图可以看出,Broker给生产者发送了Ack消息确认.由此可见,虽然消息并未正确的路由到队列中,但是Broker接收到了消息就会给生产者端发送Ack确认. Confirm确认监听情况说明 什么时候会走 handleNack 方法呢，比如磁盘写满了，MQ出现了一些异常，或者Queue容量到达上限了等等 也有可能两个方法都不走，比如生产端发送消息就失败了，或者Broker端收到消息在返回ack时中途出现了网络闪断。 这种情况就需要定时任务去抓取中间状态的消息进行最大努力尝试次数的补偿重发，从而保障消息投递的可靠性。","categories":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://lylgjiavg.github.io/categories/消息中间件/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://lylgjiavg.github.io/tags/RabbitMQ/"},{"name":"消息中间件","slug":"消息中间件","permalink":"https://lylgjiavg.github.io/tags/消息中间件/"}]},{"title":"生产端的可靠性投递","slug":"RabbitMQ06","date":"2019-09-04T12:59:07.000Z","updated":"2019-09-04T14:17:40.851Z","comments":true,"path":"2019/09/04/RabbitMQ06/","link":"","permalink":"https://lylgjiavg.github.io/2019/09/04/RabbitMQ06/","excerpt":"","text":"消息如何保证100%的投递成功?什么是生产端的可靠性投递? 保障消息的成功发出 保障MQ节点的成功接收 发送端收到MQ节点(Broker)确认应答 完善的消息进行补偿机制 生产端可靠性投递——之BAT/TMD互联网大厂的解决方案 消息落库,对消息状态进行打标 消息的延迟投递,做二次确认,回调检查 具体使用哪种要根据业务场景和并发量、数据量大小来决定 方案一: 消息信息落库,对消息状态进行打标 消息信息落库，对消息状态进行打标的方案如下图所示： 具体步骤如下: Step 1：进行业务数据入库：比如发送一条订单消息，首先把业务数据也就是订单信息进行入库，然后生成一条消息，把消息也进行入库，这条消息应该包含消息状态属性，并设置初始值比如为0，表示消息创建成功正在发送中，这种方式缺陷在于我们要对数据库进行持久化两次。 Step 2:首先要保证第一步消息都存储成功了，没有出现任何异常情况，然后生产端再进行消息发送。如果失败了就进行快速失败机制。 Step 3:MQ把消息收到的结果应答(confirm)给生产端。 Step 4:生产端有一个Confirm Listener，去异步的监听Broker回送的响应，从而判断消息是否投递成功，如果成功，去数据库查询该消息，并将消息状态更新为1，表示消息投递成功。 假设step 2 已经OK了，在第三步回送响应时，网络突然出现了闪断，导致生产端的Listener收不到这条消息的confirm应答，也就是说这条消息的状态一直为0了。 Step 5:此时我们需要设置一个规则，比如说消息在入库时候设置一个临界值timeout，5分钟之后如果状态还是0，那就需要把消息抽取出来。这里,使用分布式定时任务，去定时抓取DB中距离消息创建时间超过5分钟的且状态为0的消息。 Step 6:把抓取出来的消息进行重新投递(Retry Send)，也就是从Step 2开始继续往下走。 Step 7:当然有些消息可能由于一些实际的问题无法路由到Broker，比如routingKey设置不对，对应的队列被误删除了，这种消息即使重试多次也仍然无法投递成功，所以需要对重试次数做限制，比如限制3次，如果投递次数大于3次，那么就将消息状态更新为2，表示这个消息最终投递失败。 本方案的局限性:对于本方案，需要做两次数据库的持久化操作，在高并发场景下数据库将存在性能瓶颈。其实在核心链路中只需要对业务数据进行入库，消息没必要先入库，可以做一个消息的延迟投递，做二次确认，回调检查。 方案二:消息的延迟投递，做二次确认，回调检查 消息的延迟投递，做二次确认，回调检查的方案如下图所示: 具体步骤如下: Upstream Service(上游服务,即:生产端)，Downstream service(下游服务即:消费端)，Callback service(回调服务)。 Step1：先将业务消息进行入库，然后生产端将消息发送出去，注意一定是等数据库操作完成:之后再去发送消息。 Step 2：在发送消息之后，紧接着生产端再次发送一条消息(Second Send Delay Check)，即延迟消息投递检查，这里需要设置一个延迟时间，比如5分钟之后进行投递。 Step 3：消费端去监听指定队列，将收到的消息进行处理。 Step 4：处理完成之后，发送一个confirm消息，也就是回送响应，但是这里响应不是正常的ACK，而是重新生成一条消息，投递到MQ中。 Step 5:上面的Callback service是一个单独的服务，其实它扮演了方案一的存储消息的DB角色，它通过MQ去监听下游服务发送的confirm消息，如果Callback service收到confirm消息，那么就对消息做持久化存储，即将消息持久化到DB中。 Step6：5分钟之后延迟消息发送到MQ了，然后Callback service还是去监听延迟消息所对应的队列，收到Check消息后去检查DB中是否存在消息，如果存在，则不需要做任何处理，如果不存在或者消费失败了，那么Callback service就需要主动发起RPC通信给上游服务，告诉它延迟投递的这条消息没有找到，需要重新发送，生产端收到信息后就会重新查询业务消息然后将消息发送出去。 本方案的优势与劣势: 方案二也是互联网大厂更为经典和主流的解决方案 方案二不一定能保障百分百投递成功，但是基本上可以保障大概99.9%的消息是OK的，有些特别极端的情况只能是人工去做补偿了，或者使用定时任务去做。 方案二主要目的是为了减少数据库操作，提高并发量。 在高并发场景下，最关心的不是消息100%投递成功，而是一定要保证性能，保证能抗得住这么大的并发量。所以能减少数据库的操作就尽量减少，可以异步的进行补偿。 其实在主流程里面是没有这个Callback service的，它属于一个补偿的服务，整个核心链路就是生产端入库业务消息，发送消息到MQ，消费端监听队列，消费消息。其他的步骤都是一个补偿机制。 消费端-幂等性保障 在海量订单产出的业务高峰期，如何避免消息的重复消费问题？ 消费端实现幂等性，就意味着，我们的消息永远不会消费多次，即使我们收到多条一样的消息 主流的幂等性操作 唯一ID+指纹码 ，利用数据库主键去重好处：实现简单坏处：高并发下有DB写入的性能瓶颈解决方案：跟进ID进行分库分表进行算法路由 利用Redis的原子性去实现幂等,需要考虑的问题?1、我们是否进行数据落库，如果落库的话，关键解决的问题是数据库和缓存如何做到原子性?2、如果不落库，存储到缓存中，如何设置定时同步的策略? 深入理解幂等性###什么是幂等性 HTTP/1.1中对幂等性的定义是：一次和多次请求某一个资源对于资源本身应该具有同样的结果（网络超时等问题除外）。也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。 Methods can also have the property of “idempotence” in that (aside from error orexpiration issues) the side-effects of N &gt; 0 identical requests is the same as for asingle request. 这里需要关注几个重点： 幂等不仅仅只是一次（或多次）请求对资源没有副作用（比如查询数据库操作，没有增删改，因此没有对数据库有任何影响）。 幂等还包括第一次请求的时候对资源产生了副作用，但是以后的多次请求都不会再对资源产生副作用。 幂等关注的是以后的多次请求是否对资源产生的副作用，而不关注结果。 网络超时等问题，不是幂等的讨论范围。 幂等性是系统服务对外一种承诺（而不是实现），承诺只要调用接口成功，外部多次调用对系统的影响是一致的。声明为幂等的服务会认为外部调用失败是常态，并且失败之后必然会有重试。 什么情况下需要幂等 业务开发中，经常会遇到重复提交的情况，无论是由于网络问题无法收到请求结果而重新发起请求，或是前端的操作抖动而造成重复提交情况。 在交易系统，支付系统这种重复提交造成的问题有尤其明显，比如： 用户在APP上连续点击了多次提交订单，后台应该只产生一个订单； 向支付宝发起支付请求，由于网络问题或系统BUG重发，支付宝应该只扣一次钱。 很显然，声明幂等的服务认为，外部调用者会存在多次调用的情况，为了防止外部多次调用对系统数据状态的发生多次改变，将服务设计成幂等。 幂等VS防重上面例子中遇到的问题，只是重复提交的情况，和服务幂等的初衷是不同的。重复提交是在第一次请求已经成功的情况下，人为的进行多次操作，导致不满足幂等要求的服务多次改变状态。而幂等更多使用的情况是第一次请求不知道结果（比如超时）或者失败的异常情况下，发起多次请求，目的是多次确认第一次请求成功，却不会因多次请求而出现多次的状态变化。 什么情况下需要保证幂等性 以SQL为例，有下面三种场景，只有第三种场景需要开发人员使用其他策略保证幂等性： SELECT col1 FROM tab1 WHER col2=2，无论执行多少次都不会改变状态，是天然的幂等。 UPDATE tab1 SET col1=1 WHERE col2=2，无论执行成功多少次状态都是一致的，因此也是幂等操作。 UPDATE tab1 SET col1=col1+1 WHERE col2=2，每次执行的结果都会发生变化，这种不是幂等的。 为什么要设计幂等性的服务幂等可以使得客户端逻辑处理变得简单，但是却以服务逻辑变得复杂为代价。满足幂等服务的需要在逻辑中至少包含两点： 首先去查询上一次的执行状态，如果没有则认为是第一次请求 在服务改变状态的业务逻辑前，保证防重复提交的逻辑 幂等的不足 幂等是为了简化客户端逻辑处理，却增加了服务提供者的逻辑和成本，是否有必要，需要根据具体场景具体分析，因此除了业务上的特殊要求外，尽量不提供幂等的接口。 增加了额外控制幂等的业务逻辑，复杂化了业务功能； 把并行执行的功能改为串行执行，降低了执行效率。 保证幂等策略 幂等需要通过唯一的业务单号来保证。也就是说相同的业务单号，认为是同一笔业务。使用这个唯一的业务单号来确保，后面多次的相同的业务单号的处理逻辑和执行效果是一致的。 下面以支付为例，在不考虑并发的情况下，实现幂等很简单：①先查询一下订单是否已经支付过，②如果已经支付过，则返回支付成功；如果没有支付，进行支付流程，修改订单状态为‘已支付’。 防重复提交策略 上述的保证幂等方案是分成两步的，第②步依赖第①步的查询结果，无法保证原子性的。在高并发下就会出现下面的情况：第二次请求在第一次请求第②步订单状态还没有修改为‘已支付状态’的情况下到来。既然得出了这个结论，余下的问题也就变得简单：把查询和变更状态操作加锁，将并行操作改为串行操作。 乐观锁如果只是更新已有的数据，没有必要对业务进行加锁，设计表结构时使用乐观锁，一般通过version来做乐观锁，这样既能保证执行效率，又能保证幂等。例如： UPDATE tab1 SET col1=1,version=version+1WHERE version=#version# 不过，乐观锁存在失效的情况，就是常说的ABA问题，不过如果version版本一直是自增的就不会出现ABA的情况。（从网上找了一张图片很能说明乐观锁，引用过来，出自Mybatis对乐观锁的支持） 防重表使用订单号orderNo做为去重表的唯一索引，每次请求都根据订单号向去重表中插入一条数据。第一次请求查询订单支付状态，当然订单没有支付，进行支付操作，无论成功与否，执行完后更新订单状态为成功或失败，删除去重表中的数据。后续的订单因为表中唯一索引而插入失败，则返回操作失败，直到第一次的请求完成（成功或失败）。可以看出防重表作用是加锁的功能。 分布式锁这里使用的防重表可以使用分布式锁代替，比如Redis。订单发起支付请求，支付系统会去Redis缓存中查询是否存在该订单号的Key，如果不存在，则向Redis增加Key为订单号。查询订单支付已经支付，如果没有则进行支付，支付完成后删除该订单号的Key。通过Redis做到了分布式锁，只有这次订单订单支付请求完成，下次请求才能进来。相比去重表，将放并发做到了缓存中，较为高效。思路相同，同一时间只能完成一次支付请求。 token令牌这种方式分成两个阶段：申请token阶段和支付阶段。 第一阶段，在进入到提交订单页面之前，需要订单系统根据用户信息向支付系统发起一次申请token的请求，支付系统将token保存到Redis缓存中，为第二阶段支付使用。 第二阶段，订单系统拿着申请到的token发起支付请求，支付系统会检查Redis中是否存在该token，如果存在，表示第一次发起支付请求，删除缓存中token后开始支付逻辑处理；如果缓存中不存在，表示非法请求。 实际上这里的token是一个信物，支付系统根据token确认，你是你妈的孩子。不足是需要系统间交互两次，流程较上述方法复杂。 支付缓冲区把订单的支付请求都快速地接下来，一个快速接单的缓冲管道。后续使用异步任务处理管道中的数据，过滤掉重复的待支付订单。优点是同步转异步，高吞吐。不足是不能及时地返回支付结果，需要后续监听支付结果的异步返回。","categories":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://lylgjiavg.github.io/categories/消息中间件/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://lylgjiavg.github.io/tags/RabbitMQ/"},{"name":"消息中间件","slug":"消息中间件","permalink":"https://lylgjiavg.github.io/tags/消息中间件/"}]},{"title":"RabbitMQ-基本概念","slug":"RabbitMQ05","date":"2019-09-04T07:28:00.000Z","updated":"2019-09-04T08:52:33.040Z","comments":true,"path":"2019/09/04/RabbitMQ05/","link":"","permalink":"https://lylgjiavg.github.io/2019/09/04/RabbitMQ05/","excerpt":"","text":"RabbitMQ的基本概念Binding-绑定 Exchange和Exchange、Queue之间的连接关系 Binding中可以包含Routing Key或则参数 注意:default Exchange 不能进行Binding，也不需要进行绑定除default Exchange之外，其他任何Exchange都需要和Queue进行Binding，否则无法进行消息路由（转发）Binding的时候，可以设置一个或多个参数，其中参数要特别注意参数类型Direct Exchange、Topic Exchange进行Binding的时候，需要指定Routing keyFanout Exchange、Headers Exchange进行Binding的时候，不需要指定Routing key Queue-消息队列 消息队列，实际存储消息数据 Durability：是否持久化，Durable：是，Transient：否 Auto delete：如选yes，代表当最后一个监听被移走之后，该Queue会自动删除 注意: 关于Queue名称最长？RabbitMQ规定，队列的名字最长不超过UTF-8编码的255字节。不过一般没人无聊到声明名字那么长的队列吧。。。 关于Queue名称雷区？由于RabbitMQ内部的Queue命名规则采用 “amq.”形式，所以当我们声明自己的Queue时，注意不要与此规则冲突，否则会报异常。 关于队列属性？Durable ：代表该队列是否持久化至硬盘（若要使队列中消息不丢失，同时也需要将消息声明为持久化）；Exclusive :是否声明该队列是否为连接独占，若为独占，连接关闭后队列即被删除；Auto-delete：若没有消费者订阅该队列，队列将被删除；Arguments：可选map类型参数，可以指定队列长度，消息生存时间，镜相设置等 声明了一个已经存在的队列？如果队列已经存在，再次声明将不会起作用。若原始队列参数和该次声明时不同则会报异常。 队列中消息顺序？默认情况下是FIFO，即先进先出，同时也支持发送消息时指定消息的优先级。 队列消息存放位置？对于临时消息，RabbitMQ尽量将其存放在内存，当出现内存告警时，MQ会将消息持久化至硬盘。对于持久化消息与Lazy-queues，MQ会先将消息存入硬盘，消费时再取出。 队列中消息的消费？默认情况下，MQ会设置消费者的消费确认模式为自动。对于一些重要消息的处理，推荐确认模式改为手动。（nack和reject区别？nack可以一次拒绝多条消息） 队列中消息的消费速度？通过Prefetch（通道上最大未确认投递数量）设置消费者每次消费的条数，一般将该值设为1，但他会降低吞吐量。RabbitMQ官网建议的是100-300.（更建议反复试验得到一个表现符合期望的值） 队列中消息状态？队列中的消息共有俩种状态，一是准备投递，二是已投递但未确认。 队列最大长度？声明队列时可以指定最大长度，需要注意的是只限制状态为准备投递的数量，未确认的消息不计算在内。当队列长度超过限制，MQ会根据策略选择丢弃（默认）或者将消息投递进死信队列。 关于死信队列？其实更准确的说法是死信交换机，提前声明一个交换机，在声明队列时使用“x-dead-letter-exchange”参数（可指定routKey）将队列绑定到该死信交换机。消息有以下情况之一会成为死信：被reject或者nack，消息超过生存时间，队列长度超过限制。 关于不能路由到队列的消息？这个和上面一样，其实不算Queue系列而是Exchange。针对消息无法路由到队列的情况MQ提供了AlternateExchange处理。声明Exchange时添加args.put(“alternate-exchange”,”my-ae”)参数。即当该交换机存在无法路由的消息时，它将消息发布到AE上，AE把消息路由到绑定在他上面的消息。 Message-消息 服务器和应用程序之间传送的数据 本质上就是一段数据，由Properties和Payload（Body）组成 发送消息可以为消息指定一些参数Delivery mode: 是否持久化，1 - Non-persistent，2 - PersistentHeaders：Headers can have any name. Only long string headers can be set here.Properties: You can set other message properties here (delivery mode and headers arepulled out as the most common cases). Invalid properties will be ignored.Valid properties are: content_type ： 消息内容的类型 content_encoding： 消息内容的编码格式 priority： 消息的优先级 correlation_id：关联id reply_to: 用于指定回复的队列的名称 expiration： 消息的失效时间 message_id： 消息id timestamp：消息的时间戳 type： 类型 user_id: 用户id app_id： 应用程序id cluster_id: 集群id Payload: 消息内容————————————————版权声明：本文为CSDN博主「gmHappy」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/ctwy291314/article/details/83183633 注意: 如何保证消息不丢失 Exchange需要持久化 Queue需要持久化 Message需要持久化 Virtual host-虚拟主机 虚拟地址，用于进行逻辑隔离，最上层的消息路由 一个Virtual Host里面可以有若干个Exchange和Queue 同一个Virtual Host里面不能有相同名称的Exchange和Queue","categories":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://lylgjiavg.github.io/categories/消息中间件/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://lylgjiavg.github.io/tags/RabbitMQ/"},{"name":"消息中间件","slug":"消息中间件","permalink":"https://lylgjiavg.github.io/tags/消息中间件/"}]},{"title":"RabbitMQ-Exchange","slug":"RabbitMQ04","date":"2019-09-03T04:03:55.000Z","updated":"2019-09-07T02:45:43.196Z","comments":true,"path":"2019/09/03/RabbitMQ04/","link":"","permalink":"https://lylgjiavg.github.io/2019/09/03/RabbitMQ04/","excerpt":"","text":"Exchanges(交换机) Exchange:接收消息,并根据路由键转发消息所绑定的队列. 下图为RabbitMQ的整体工作示意图: 交换机属性: Name: 交换机名称 Type: 交换机类型:direct,topic,fanout,headers Durability: 是否需要持久化,true为持久化 Auto Delete:当最后一个绑定到ExChange的队列删除后,自动删除该Exchange Internal:当前Exchange是否用于RabbitMQ内部使用,默认为false Arguments:扩展参数,用于扩展AMQP协议自制定化使用 交换机类型 direct处理路由键。需要将一个队列绑定到交换机上，要求该消息与一个特定的路由键完全匹配。这是一个完整的匹配。如果一个队列绑定到该交换机上要求路由键 “abc”，则只有被标记为“abc”的消息才被转发，不会转发abc.def，也不会转发dog.ghi，只会转发abc。 topic将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“”匹配不多不少一个词。因此“abc.#”能够匹配到“abc.def.ghi”，但是“abc.” 只会匹配到“abc.def”。 fanout不处理路由键。你只需要简单的将队列绑定到交换机上。一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。Fanout交换机转发消息是最快的。 headers不处理路由键。而是根据发送的消息内容中的headers属性进行匹配。在绑定Queue与Exchange时指定一组键值对；当消息发送到RabbitMQ时会取到该消息的headers与Exchange绑定时指定的键值对进行匹配；如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers属性是一个键值对，可以是Hashtable，键值对的值可以是任何类型。而fanout，direct，topic 的路由键都需要要字符串形式的。匹配规则x-match有下列两种类型：x-match = all ：表示所有的键值对都匹配才能接受到消息x-match = any ：表示只要有键值对匹配就能接受到消息 Direct Exchange 所有发送到Direct Exchange的消息被转发到RouteKey中指定的Queue. 以下为Direct模式下Exchange的工作示意图: 注意:Direct模式可以使用RabbitMQ自带的Exchange:default Exchange,所以不需要将Exchange进行任何绑定(binding)操作,消息传递时,RoutKey必须完全匹配才会被队列接收,否则该消息会被抛弃. Direct Exchange演示消费者代码 消费者代码如下 import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import com.rabbitmq.client.QueueingConsumer; /** * @Classname Consumer * @Description RabbitMQ的Direct模式:消费者 * @Date 2019/9/3 13:37 * @Created by Jiavg */ public class Consumer { public static void main(String[] args) throws Exception{ // 1.创建ConnectionFactory ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(\"127.0.0.1\"); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(\"/\"); connectionFactory.setUsername(\"guest\"); connectionFactory.setPassword(\"guest\"); // 2.通过连接工厂获得连接 Connection connection = connectionFactory.newConnection(); // 3.通过连接创建信道 Channel channel = connection.createChannel(); String exchangeName = \"test_Direct_Exchange\"; String exchangeType = \"direct\"; String queueName = \"test_Direct_Queue\"; String routeKey = \"test.direct\"; // 4.声明一个交换机 channel.exchangeDeclare(exchangeName,exchangeType,true, false, false, null); // 5.声明一个队列 channel.queueDeclare(queueName, true, false, false, null); // 6. 建立一个绑定关系 channel.queueBind(queueName, exchangeName, routeKey); // 7.创建一个消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 8.设置信道参数:队列,是否自动ACK,Consumer channel.basicConsume(queueName, true, consumer); // 9.读取消息 while (true){ QueueingConsumer.Delivery delivery = consumer.nextDelivery(); byte[] body = delivery.getBody(); String msg = new String(body); System.out.println(msg); } } } 消费者运行 在运行消费者后,RabbitMQ的管控台变化如下: Connections视口 Channel视口 Exchanges视口 由上图可以观察到,声明的交换机(“test_Direct_Exchange”)为direct模式. Queues视口 生产者代码 生产者代码如下 import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; /** * @Classname Producer * @Description RabbitMQ的Direct模式:生产者 * @Date 2019/9/3 13:27 * @Created by Jiavg */ public class Producer { public static void main(String[] args) throws Exception{ // 1.创建ConnectionFactory ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(\"127.0.0.1\"); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(\"/\"); connectionFactory.setUsername(\"guest\"); connectionFactory.setPassword(\"guest\"); // 2.通过连接工厂获得连接 Connection connection = connectionFactory.newConnection(); // 3.通过连接创建信道 Channel channel = connection.createChannel(); // 4.声明交换机名称及路由键 String exchangeName = \"test_Direct_Exchange\"; String routeKey = \"test.direct\"; // 5.发送消息 String msg = \"Hello World RabbitMQ 4 Direct Exchange message...\"; channel.basicPublish(exchangeName, routeKey, null, msg.getBytes()); // 6.关闭资源 channel.close(); connection.close(); } } 生产者运行 在运行生产者代码后,RabbitMQ的管控台界面如下图所示: 并且消费者控制台输出如下 可见,在交换机类型为direct模式时,RabbitMQ的交换机根据路由键将接受到的消息路由到相应的队列中,并被相应的监听消费者消费该消息. Topic Exchange 所有发送到Topic Exchange的消息被转发到所有关心RouteKey中指定的Topic Queue上 Exchange将RouteKey和某Topic进行模糊匹配,此时队列需要绑定一个Topic以下为Topic模式下Exchange的工作示意图:注意:可以使用通配符进行模糊匹配符号: “#”匹配一个或多个词符号: “*”匹配不多不少一个词例如: “log.#”能够匹配到”log.info.oa”“log.*”只会匹配到”log.error” Topic Exchange演示消费者代码 消费者代码如下 import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import com.rabbitmq.client.QueueingConsumer; /** * @Classname Consumer * @Description RabbitMQ的Topic模式:消费者 * @Date 2019/9/3 16:02 * @Created by Jiavg */ public class Consumer { public static void main(String[] args) throws Exception{ // 1.创建ConnectionFactory ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(\"127.0.0.1\"); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(\"/\"); connectionFactory.setUsername(\"guest\"); connectionFactory.setPassword(\"guest\"); // 2.通过连接工厂获得连接 Connection connection = connectionFactory.newConnection(); // 3.通过连接创建信道 Channel channel = connection.createChannel(); String exchangeName = \"test_Topic_Exchange\"; String exchangeType = \"topic\"; String routeKey = \"test.*\"; String queueName = \"test_Topic_Queue\"; // 4.声明交换机 channel.exchangeDeclare(exchangeName, exchangeType, true, false,false,null); // 5.声明队列 channel.queueDeclare(queueName, true, false, false, null); // 6.创建消费者 QueueingConsumer queueingConsumer = new QueueingConsumer(channel); // 7.绑定队列到交换机上(利用topic模式的routeKey) channel.queueBind(queueName, exchangeName, routeKey); // 8.设置参数 channel.basicConsume(queueName, true, queueingConsumer); // 8.接收消息 while (true) { QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery(); byte[] body = delivery.getBody(); String msg = new String(body); System.out.printf(msg); } } } 消费者运行 在运行消费者后,RabbitMQ的管控台变化如下: Exchanges视口 由上图可以观察到,声明的交换机(“test_Topic_Exchange”)为topic模式. 生产者代码 生产者代码如下 import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; /** * @Classname Producer * @Description RabbitMQ的Topic模式:生产者 * @Date 2019/9/3 15:56 * @Created by Jiavg */ public class Producer { public static void main(String[] args) throws Exception{ // 1.创建ConnectionFactory ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(\"127.0.0.1\"); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(\"/\"); connectionFactory.setUsername(\"guest\"); connectionFactory.setPassword(\"guest\"); // 2.通过连接工厂获得连接 Connection connection = connectionFactory.newConnection(); // 3.通过连接创建信道 Channel channel = connection.createChannel(); String msg1 = \"Hello World Topic Exchange with routeKey for test.hello\"; String msg2 = \"Hello World Topic Exchange with routeKey for test.hello.world\"; String msg3 = \"Hello World Topic Exchange with routeKey for hello.world\"; String routeKey1 = \"test.hello\"; String routeKey2 = \"test.hello.world\"; String routeKey3 = \"hello.world\"; String exchangeName = \"test_Topic_Exchange\"; // 4.发送消息 channel.basicPublish(exchangeName, routeKey1, null, msg1.getBytes()); channel.basicPublish(exchangeName, routeKey2, null, msg2.getBytes()); channel.basicPublish(exchangeName, routeKey3, null, msg3.getBytes()); // 5.关闭资源 channel.close(); connection.close(); } } 生产者运行 消费者控制台输出如下 可见,在交换机类型为topic模式时,RabbitMQ的交换机根据生产者发送消息的路由键将接受到的消息根据topic模式的路由键路由到相应的队列中,并被相应的监听消费者消费该消息.(注意通配符的模糊匹配) Fanout Exchange 不处理路由键,只需要简单的将队列绑定到交换机上 发送到交换机的消息都会被转发到与该交换机绑定的所有队列上 Fanout交换机转发消息是最快的以下为Fanout模式下Exchange的工作示意图: Fanout Exchange演示消费者代码 消费者代码如下 import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import com.rabbitmq.client.QueueingConsumer; /** * @Classname Consumer * @Description RabbitMQ的Fanout模式:消费者 * @Date 2019/9/3 17:14 * @Created by Jiavg */ public class Consumer { public static void main(String[] args) throws Exception{ // 1.创建ConnectionFactory ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(\"127.0.0.1\"); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(\"/\"); connectionFactory.setUsername(\"guest\"); connectionFactory.setPassword(\"guest\"); // 2.通过连接工厂获得连接 Connection connection = connectionFactory.newConnection(); // 3.通过连接创建信道 Channel channel = connection.createChannel(); String exchangeName = \"test_Fanout_Exchange\"; String exchangeType = \"fanout\"; String queueName = \"test_Fanout_Queue\"; String routeKey = \"\"; channel.exchangeDeclare(exchangeName, exchangeType, true, false,false, null); channel.queueDeclare(queueName, true, false, false, null); channel.queueBind(queueName, exchangeName, routeKey); QueueingConsumer queueingConsumer = new QueueingConsumer(channel); channel.basicConsume(queueName, true, queueingConsumer); while (true) { QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery(); byte[] body = delivery.getBody(); String msg = new String(body); System.out.printf(msg); } } } 消费者运行 在运行消费者后,RabbitMQ的管控台变化如下: Exchanges视口 由上图可以观察到,声明的交换机(“test_Fanout_Queue”)为fanout模式. 生产者代码 生产者代码如下 import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; /** * @Classname Producer * @Description RabbitMQ的Fanout模式:生产者 * @Date 2019/9/3 22:14 * @Created by Jiavg */ public class Producer { public static void main(String[] args) throws Exception{ // 1.创建ConnectionFactory ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(\"127.0.0.1\"); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(\"/\"); connectionFactory.setUsername(\"guest\"); connectionFactory.setPassword(\"guest\"); // 2.通过连接工厂获得连接 Connection connection = connectionFactory.newConnection(); // 3.通过连接创建信道 Channel channel = connection.createChannel(); String exchangeName = \"test_Fanout_Exchange\"; String routeKey = \"\"; String msg = \"Hello World Fanout Exchange\"; channel.basicPublish(exchangeName, routeKey, null, msg.getBytes()); } } 生产者运行 消费者控制台输出如下 可见,在交换机类型为fanout模式时,RabbitMQ不处理路由键,只需要简单的将队列绑定到交换机上,发送到交换机的消息都会被转发到与该交换机绑定的所有队列上.","categories":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://lylgjiavg.github.io/categories/消息中间件/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://lylgjiavg.github.io/tags/RabbitMQ/"},{"name":"消息中间件","slug":"消息中间件","permalink":"https://lylgjiavg.github.io/tags/消息中间件/"}]},{"title":"设计模式概要","slug":"设计模式01","date":"2019-09-02T10:24:51.000Z","updated":"2019-09-07T09:44:43.997Z","comments":true,"path":"2019/09/02/设计模式01/","link":"","permalink":"https://lylgjiavg.github.io/2019/09/02/设计模式01/","excerpt":"","text":"设计模式的目的 在编写软件的过程中,程序员面临着来自耦合性,内聚性以及可维护性,可扩展性,重用性,灵活性等多方面的挑战,设计模式是为了让程序(软件),具有更好 代码重用性 (即:相同功能的代码,不用多次编写) 可读性 (即:编程规范性,便于其他程序员的阅读和理解) 可扩展性 (即:当需要添加新功能时,非常的方便,也称为可维护性) 可靠性 (即:当我们添加新的功能时,对原来的功能没有影响) 使程序呈现高内聚,低耦合的特性 分享金句 设计模式包含了面向对象的精髓,”懂得了设计模式,你就懂得了面向对象分析和设计(OOA/D)的精要” 设计模式七大原则 设计模式原则,其实就是程序员在编写程序时,应当遵守的原则,也是各种设计模式的基础(即:设计模式为什么这样设计的依据). 设计模式常用的七大原则有 单一职责原则 接口隔离原则 依赖倒置原则 里氏替换原则 开闭原则 迪米特法则 合成复用原则 单一职责原则(SRP:Single Responsibility Principle) 基本介绍 对类来说,即一个类应该只负责一项职责. 如类A负责两个不同的职责:职责1,职责2.当职责1需求变更而改变A时,可能造成职责2执行错误,所以需要将类A的粒度分解为A1,A2. 注意事项及细节 降低类的复杂度,一个类只负责一项职责. 提高类的可读性,可维护性. 降低变更引起的风险. 通常情况下,我们应该严格遵守单一职责原则,只有逻辑足够简单,才可以在代码级违反单一职责原则;只有类中方法数量足够少,可以在方法级别保持单一职责原则. 接口隔离原则(ISP:Interface Segregation Principle) 基本介绍 客户端不应该依赖他不需要的接口,即一个类对另一个类的依赖应该建立在最小的接口上.接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。 接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的： 单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。 单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。 接口隔离原则的优点 接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。 将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。 接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。 如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。 使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。 能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。 接口隔离原则的实现方法 在具体应用接口隔离原则时，应该根据以下几个规则来衡量。 接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。 为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。 了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。 依赖倒置原则(DIP:Dependence Inversion Principle) 基本介绍 高层模块不应该依赖低层模块,二者都应该依赖其抽象 抽象不应该依赖细节,细节应该依赖抽象 依赖倒置的中心思想是面向接口编程 依赖倒置原则是基于这样的设计理念:相对于细节的多变性,抽象的东西要稳定的多.以抽象为基础搭建的架构比以细节为基础的架构要稳定的多.在java中,抽象指的是接口或抽象类,细节就是具体的实现. 使用接口或抽象类的目的是制定好规范,而不涉及任何具体的操作,把展现细节的任务交给他们的实现类去完成. 依赖关系传递的三种方式 接口传递例: // 方式1:通过接口传递实现依赖 interface IOpenAndClose { public void open(ITV itv); } interface ITV { public void play(); } class OpenAndClose implements IOpenAndClose { public void open(ITV itv) { itv.play(); } } 构造方法传递例: // 方式2:通过构造方法依赖传递 interface IOpenAndClose { public void open(); } interface ITV { public void play(); } class OpenAndClose implements IOpenAndClose { public ITV tv; public OpenAndClose(ITV tv) { this.tv = tv; } public void open() { this.tv.play(); } } Setter方式传递例: // 方式3:通过setter方法传递 interface IOpenAndClose { public void open(); } interface ITV { public void play(); } class OpenAndClose implements IOpenAndClose { private ITV tv; public void setTv(ITV tv) { this.tv = tv; } public void open() { this.tv.play(); } } 注意事项及细节 低层模块尽量都要有抽象类或接口,或者两者都有,程序稳定性更好. 变量的声明类型尽量是抽象类或接口,这样我们的变量引用和实际对象间,就存在一个缓冲层,利于程序扩展和优化. 继承时遵循里氏替换原则. 里氏替换原则(LSP:Liskov Substitution Principle) OO中的继承性的思考和说明 继承包含这样一层定义:父类中凡是已经实现好的方法,实际上是在设定规范和契约,虽然它不强制要求所有的子类必须遵守这些契约,但是如果子类对这些已经实现的方法任意修改,就会对整个继承体系造成破坏. 继承在给程序设计带来便利的同时,也带来了弊端.比如使用继承会给程序带来侵入性,程序的可移植性降低,增加对象间的耦合性,如果一个类被其他类所继承,则当这个类需要修改时,必须考虑所有的子类,并且父类修改后,所有涉及到的子类的功能都可能产生故障. 问题提出:在编程中,如何正确的使用继承? ==&gt; 里氏替换原则 基本介绍 里氏替换原则（Liskov Substitution Principle，LSP）由麻省理工学院计算机科学实验室的里斯科夫（Liskov）女士在 1987 年的“面向对象技术的高峰会议”（OOPSLA）上发表的一篇文章《数据抽象和层次》（Data Abstraction and Hierarchy）里提出来的，她提出：继承必须确保超类所拥有的性质在子类中仍然成立（Inheritance should ensure that any property proved about supertype objects alsoholds for subtype objects）。 里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：所有引用基类的地方必须能透明的使用其子类的对象.子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。 如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。 里氏替换原则告诉我们,继承实际上让两个类耦合性增强了,在适当情况下,原来的父类和子类都继承一个更通俗的基类,原有的继承关系去掉,可以通过聚合,组合,依赖来解决问题. 里氏替换原则的作用 里氏替换原则是实现开闭原则的重要方式之一。 它克服了继承中重写父类造成的可复用性变差的缺点。 它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。 开闭原则(OCP:Open Closed Principle) 基本介绍 开闭原则是编程中最基础,最重要的原则. 一个软件实体如类、模块和函数应该对扩展开放(对提供方),对修改关闭（对使用方）。用抽象构建框架，用实现扩展细节。 当软件需要变化时，尽量通过扩展软件实体的行为来发生变化，而不是通过修改已有的代码来实现变化。 编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则。 开闭原则的作用 开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下。 对软件测试的影响软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。 可以提高代码的可复用性粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。 可以提高软件的可维护性遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。 开闭原则的实现方法 可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。 因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。 迪米特法则（LoD：Law of Demeter） 基本介绍 一个对象应该对其他对象保持最少的了解。 类与类关系越密切，耦合度越大。 迪米特法则又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑分装在类的内部。对外除了提供public方法，不对外泄露任何信息。 迪米特法则还有一个简单的定义:只与直接的朋友通信 直接的朋友:每个对象都会与其他对象有耦合关系,只要两个对象之间有耦合关系,我们就说这两个对象之间是朋友关系.耦合的方式有很多,依赖,关联,组合,聚合等.其中,我们称出现成员变量,方法参数,方法返回值中的类为直接的朋友,而出现在局部变量中的类不是直接朋友关系.也就是说,陌生的类最好不要以局部变量的形式出现在类的内部. 迪米特法则的优点 迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点。 降低了类之间的耦合度，提高了模块的相对独立性。 由于亲合度降低，从而提高了类的可复用率和系统的扩展性。 但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。 迪米特法则的实现方法 从迪米特法则的定义和特点可知，它强调以下两点： 从依赖者的角度来说，只依赖应该依赖的对象。 从被依赖者的角度说，只暴露应该暴露的方法。 所以，在运用迪米特法则时要注意以下 6 点。 在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。 在类的结构设计上，尽量降低类成员的访问权限。 在类的设计上，优先考虑将一个类设置成不变类。 在对其他类的引用上，将引用其他对象的次数降到最低。 不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。 谨慎使用序列化（Serializable）功能。 迪米特法则注意事项和细节 迪米特法则的核心是降低类之间的耦合 但是注意:由于每个类都减少了不必要的依赖,因此迪米特法则只是要求降低类间(对象间)耦合关系,并不是要求完全没有依赖关系. 合成复用原则(CRP:Composite Reuse Principle) 基本介绍 原则是尽量使用合成/聚合的方式,而不是使用继承. 设计核心思想 找出应用中可能需要的变化之处,把他们独立出来,不要和那些不需要变化的代码混在一起. 针对接口编程,而不是针对实现编程. 为了交互对象之间的松耦合设计而努力. 合成复用原则的重要性 通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。 采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。 合成复用原则的实现方法 合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lylgjiavg.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lylgjiavg.github.io/tags/设计模式/"}]},{"title":"RabbitMQ快速入门","slug":"RabbitMQ03","date":"2019-09-02T04:17:03.000Z","updated":"2019-09-07T02:44:37.277Z","comments":true,"path":"2019/09/02/RabbitMQ03/","link":"","permalink":"https://lylgjiavg.github.io/2019/09/02/RabbitMQ03/","excerpt":"","text":"RabbitMQ入门RabbitMQ 中 Connection 和 Channel 我们知道无论是生产者还是消费者，都需要和 RabbitMQ Broker 建立连接，这个连接就是一条 TCP 连接，也就是 Connection。 一旦 TCP 连接建立起来，客户端紧接着可以创建一个 AMQP 信道（Channel），每个信道都会被指派一个唯一的 ID。 信道是建立在 Connection 之上的虚拟连接，RabbitMQ 处理的每条 AMQP 指令都是通过信道完成的。 我们完全可以使用 Connection 就能完成信道的工作，为什么还要引入信道呢？ 试想这样一个场景，一个应用程序中有很多个线程需要从 RabbitMQ 中消费消息，或者生产消息，那么必然需要建立很多个 Connection，也就是多个 TCP 连接。然而对于操作系统而言，建立和销毁 TCP 连接是非常昂贵的开销，如果遇到使用高峰，性能瓶颈也随之显现。 RabbitMQ 采用类似 NIO（Non-blocking I/O）的做法，选择 TCP 连接复用，不仅可以减少性能开销，同时也便于管理。 每个线程把持一个信道，所以信道复用了 Connection 的 TCP 连接。同时 RabbitMQ 可以确保每个线程的私密性，就像拥有独立的连接一样。当每个信道的流量不是很大时，复用单一的 Connection 可以在产生性能瓶颈的情况下有效地节省 TCP 连接资源。但是信道本身的流量很大时，这时候多个信道复用一个Connection 就会产生性能瓶颈，进而使整体的流量被限制了。此时就需要开辟多个 Connection，将这些信道均摊到这些 Connection 中，至于这些相关的调优策略需要根据业务自身的实际情况进行调节。 信道在 AMQP 中是一个很重要的概念，大多数操作都是在信道这个层面展开的。比如 channel.exchangeDeclare、channel.queueDeclare、channel.basicPublish、channel.basicConsume 等方法。RabbitMQ 相关的 API 与 AMQP 紧密相连，比如 channel.basicPublish 对应 AMQP 的 Basic.Publish 命令。 名词解释：NIO，也称非阻塞 I/O，包含三大核心部分：Channel（信道）、Buffer（缓冲区）和 Selector（选择器）。NIO 基于 Channel 和 Buffer 进行操作，数据总是从信道读取数据到缓冲区中，或者从缓冲区写入到信道中。Selector 用于监听多个信道的时间（比如连接打开，数据到达等）。因此，单线程可以监听多个数据的信道。 创建Java项目在pom文件中引入RabbitMQ依赖项: &lt;!-- https://mvnrepository.com/artifact/com.rabbitmq/amqp-client --> &lt;dependency> &lt;groupId>com.rabbitmq&lt;/groupId> &lt;artifactId>amqp-client&lt;/artifactId> &lt;version>3.6.5&lt;/version> &lt;/dependency> 创建消费者import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import com.rabbitmq.client.QueueingConsumer; /** * @Classname Consumer * @Description RabbitMQ消费者 * @Date 2019/9/2 11:02 * @Created by Jiavg */ public class Consumer { public static void main(String[] args) throws Exception { // 1.创建一个ConnectionFactory,并进行配置 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(\"127.0.0.1\"); connectionFactory.setUsername(\"guest\"); connectionFactory.setPassword(\"guest\"); connectionFactory.setVirtualHost(\"/\"); // 2.通过连接工厂创建连接 Connection connection = connectionFactory.newConnection(); // 3.通过connection创建一个Channel Channel channel = connection.createChannel(); // 4.声明(创建)一个队列 String queueName = \"test001\"; // queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete,Map&lt;String, Object> arguments) // param queue the name of the queue // @param durable true if we are declaring a durable queue (the queue will survive a server restart) // @param exclusive true if we are declaring an exclusive queue (restricted to this connection) // @param autoDelete true if we are declaring an autodelete queue (server will delete it when no longer in use) // @param arguments other properties (construction arguments) for the queue channel.queueDeclare(queueName, true, false,false,null); // 5.创建消费者 QueueingConsumer queueingConsumer = new QueueingConsumer(channel); // 6.设置Channel channel.basicConsume(queueName, true, queueingConsumer); // 7.获取消息 while (true){ QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery(); byte[] body = delivery.getBody(); String msg = new String(body); System.out.println(\"消费者:\" + msg); } } } 运行消费者类 在运行消费者类Consumer后,RabbitMQ的浏览器管控台信息状况如下图所示: 运行消费者类之前: 由上图可以看到: 在全局参数(Global counts)中:连接数量(Connections)为0,信道(Channels)数量为0,队列(Queues)数量为0,以及消费者(Consumers)数量为0 运行消费者之后由上图可以看到: 在全局参数(Global counts)中:连接数量(Connections)为1,信道(Channels)数量为1,队列(Queues)数量为1,以及消费者(Consumers)数量为1. 可以了解到: channel.queueDeclare(queueName, true, false,false,null);此行代码创建了一个名字为”test001”(即queueName变量值)的队列,且与RabbitMQ保持一个连接,此连接内包含一个信道. QueueingConsumer queueingConsumer = new QueueingConsumer(channel);channel.basicConsume(queueName, true, queueingConsumer);这两行代码创建一个消费者,并把消费者绑定到已创建的队列上. 创建生产者类import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; /** * @Classname Producer * @Description RabbitMQ生产者 * @Date 2019/9/2 10:54 * @Created by Jiavg */ public class Producer { public static void main(String[] args) throws Exception { // 1.创建一个ConnectionFactory,并进行配置 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(\"127.0.0.1\"); connectionFactory.setUsername(\"guest\"); connectionFactory.setPassword(\"guest\"); connectionFactory.setVirtualHost(\"/\"); // 2.通过连接工厂创建连接 Connection connection = connectionFactory.newConnection(); // 3.通过connection创建一个Channel Channel channel = connection.createChannel(); for (int i = 0; i &lt; 5; i++){ String message = \"Hello RabbitMQ!\"; // 4.通过Channel发送数据 // basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body) channel.basicPublish(\"\", \"test001\", null, message.getBytes()); } // 5.关闭相关连接 channel.close(); connection.close();; } } 运行生产者类 在运行生产者类Producer后,RabbitMQ的浏览器管控台信息状况如下图所示: 运行生产者类之前: 由上图可以看到: 消息队列(Queued messages)为空,消息消费速率(Message rates)也为0 运行生产者之后 且消费者控制台显示: 由上图可以看到: 消息队列(Queued messages)为空,消息消费速率(Message rates)迅速上升并下降 消费者接收到生产者发送的信息 以上便是RabbitMQ快速入门.","categories":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://lylgjiavg.github.io/categories/消息中间件/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://lylgjiavg.github.io/tags/RabbitMQ/"},{"name":"消息中间件","slug":"消息中间件","permalink":"https://lylgjiavg.github.io/tags/消息中间件/"}]},{"title":"RabbitMQ命令行与管控台","slug":"RabbitMQ02","date":"2019-09-02T00:15:36.000Z","updated":"2019-09-04T07:29:46.747Z","comments":true,"path":"2019/09/02/RabbitMQ02/","link":"","permalink":"https://lylgjiavg.github.io/2019/09/02/RabbitMQ02/","excerpt":"","text":"命令行与管控台-基础操作 启动应用 [root@Jiavg /]# rabbitmqctl start_app Starting node rabbit@Jiavg … 节点状态 [root@Jiavg /]# rabbitmqctl status Status of node rabbit@Jiavg ... [{pid,24387}, {running_applications, [{rabbitmq_management,&quot;RabbitMQ Management Console&quot;,&quot;3.6.6&quot;}, {rabbitmq_management_agent,&quot;RabbitMQ Management Agent&quot;,&quot;3.6.6&quot;}, {rabbitmq_web_dispatch,&quot;RabbitMQ Web Dispatcher&quot;,&quot;3.6.6&quot;}, {rabbit,&quot;RabbitMQ&quot;,&quot;3.6.6&quot;}, {os_mon,&quot;CPO CXC 138 46&quot;,&quot;2.4.1&quot;}, {amqp_client,&quot;RabbitMQ AMQP Client&quot;,&quot;3.6.6&quot;}, {rabbit_common,[],&quot;3.6.6&quot;}, {webmachine,&quot;webmachine&quot;,&quot;1.10.3&quot;}, {mochiweb,&quot;MochiMedia Web Server&quot;,&quot;2.13.1&quot;}, {mnesia,&quot;MNESIA CXC 138 12&quot;,&quot;4.14&quot;}, {inets,&quot;INETS CXC 138 49&quot;,&quot;6.3.2&quot;}, {ssl,&quot;Erlang/OTP SSL application&quot;,&quot;8.0.1&quot;}, {public_key,&quot;Public key infrastructure&quot;,&quot;1.2&quot;}, {xmerl,&quot;XML parser&quot;,&quot;1.3.11&quot;}, {crypto,&quot;CRYPTO&quot;,&quot;3.7&quot;}, {compiler,&quot;ERTS CXC 138 10&quot;,&quot;7.0.1&quot;}, {asn1,&quot;The Erlang ASN1 compiler version 4.0.3&quot;,&quot;4.0.3&quot;}, {ranch,&quot;Socket acceptor pool for TCP protocols.&quot;,&quot;1.2.1&quot;}, {syntax_tools,&quot;Syntax tools&quot;,&quot;2.0&quot;}, {sasl,&quot;SASL CXC 138 11&quot;,&quot;3.0&quot;}, {stdlib,&quot;ERTS CXC 138 10&quot;,&quot;3.0.1&quot;}, {kernel,&quot;ERTS CXC 138 10&quot;,&quot;5.0.1&quot;}]}, {os,{unix,linux}}, {erlang_version, &quot;Erlang/OTP 19 [erts-8.0.3] [source] [64-bit] [smp:2:2] [async-threads:64] [hipe] [kernel-poll:true]\\n&quot;}, {memory, [{total,55645528}, {connection_readers,0}, {connection_writers,0}, {connection_channels,0}, {connection_other,2832}, {queue_procs,2832}, {queue_slave_procs,0}, {plugins,770696}, {other_proc,18182848}, {mnesia,67616}, {mgmt_db,661496}, {msg_index,44080}, {other_ets,1430128}, {binary,29576}, {code,24640713}, {atom,1000625}, {other_system,8812086}]}, {alarms,[]}, {listeners,[{clustering,25672,&quot;::&quot;},{amqp,5672,&quot;::&quot;}]}, {vm_memory_high_watermark,0.4}, {vm_memory_limit,767174246}, {disk_free_limit,50000000}, {disk_free,20552192000}, {file_descriptors, [{total_limit,924},{total_used,2},{sockets_limit,829},{sockets_used,0}]}, {processes,[{limit,1048576},{used,228}]}, {run_queue,0}, {uptime,80}, {kernel,{net_ticktime,60}}] 关闭应用 [root@Jiavg /]# rabbitmqctl stop_app Stopping node rabbit@Jiavg … 注意: 如果在关闭RabbitMQ管控台(即使用rabbitmqctl stop_app命令)后,重新启动管控台,可能会出现如下情况: [root@Jiavg /]# rabbitmqctl start_app Starting node rabbit@Jiavg ... Error: unable to connect to node rabbit@Jiavg: nodedown DIAGNOSTICS =========== attempted to contact: [rabbit@Jiavg] rabbit@Jiavg: * connected to epmd (port 4369) on Jiavg * epmd reports: node &#39;rabbit&#39; not running at all no other nodes on Jiavg * suggestion: start the node current node details: - node name: &#39;rabbitmq-cli-99@Jiavg&#39; - home dir: /var/lib/rabbitmq - cookie hash: aTORW4S5X/Uol6/P8PSLqw== 解决方案: 1.kill掉RabbitMQ所有进程 2.重启RabbitMQ服务 [root@Jiavg /]# rabbitmq-server start RabbitMQ 3.6.6. Copyright (C) 2007-2016 Pivotal Software, Inc. ## ## Licensed under the MPL. See http://www.rabbitmq.com/ ## ## ########## Logs: /var/log/rabbitmq/rabbit@Jiavg.log ###### ## /var/log/rabbitmq/rabbit@Jiavg-sasl.log ########## Starting broker... completed with 6 plugins. 3.重新运行rabbitmqctl start_app命令 使用lsof命令查看RabbitMQ状态 lsof(list open files)是一个列出当前系统打开文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。所以如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，无论这个文件的本质如何，该文件描述符为应用程序与基础操作系统之间的交互提供了通用接口。因为应用程序打开文件的描述符列表提供了大量关于这个应用程序本身的信息，因此通过lsof工具能够查看这个列表对系统监测以及排错将是很有帮助的。 [root@Jiavg /]# lsof -i:5672 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME beam.smp 24387 rabbitmq 53u IPv6 139726 0t0 TCP *:amqp (LISTEN) 添加用户 rabbitmqctl add_user username password [root@Jiavg /]# rabbitmqctl add_user jiavg jiavg Creating user “jiavg” … 列出所有用户 rabbitmqctl list_users [root@Jiavg /]# rabbitmqctl list_users Listing users … jiavg [] guest [administrator] 修改密码 rabbitmqctl change_password username newpassword [root@Jiavg /]# rabbitmqctl change_password jiavg jiavg123 Changing password for user “jiavg” .. 删除用户 rabbitmqctl delete_user username [root@Jiavg /]# rabbitmqctl delete_user jiavg Deleting user “jiavg” … 创建虚拟主机 *rabbitmqctl add_vhost *vhostpath ** [root@Jiavg /]# rabbitmqctl add_vhost /test Creating vhost “/test” … 列出所有虚拟主机 rabbitmqctl list_vhosts [root@Jiavg /]# rabbitmqctl list_vhosts Listing vhosts … /test / 设置用户权限 rabbitmqctl set_permissions -p vhostpath username “.“ “.*” “.*”* [root@Jiavg /]# rabbitmqctl set_permissions -p /test jiavg “.*” “.*” “.*” Setting permissions for user “jiavg” in vhost “/test” … 列出虚拟主机上所有权限 rabbitmqctl list_permissions -p vhostpath [root@Jiavg /]# rabbitmqctl list_permissions -p /test Listing permissions in vhost “/test” … jiavg .* .* .* 清除用户权限 rabbitmqctl clear_permissions -p vhostpath username [root@Jiavg /]# rabbitmqctl clear_permissions -p /test jiavg Clearing permissions for user “jiavg” in vhost “/test” … 查看所有交换机信息 rabbitmqctl list_exchanges [root@Jiavg /]# rabbitmqctl list_exchanges Listing exchanges … direct amq.fanout fanout amq.headers headers amq.rabbitmq.log topic amq.direct direct amq.match headers amq.rabbitmq.trace topic amq.topic topic 查看所有队列信息 rabbitmqctl list_queues [root@Jiavg /]# rabbitmqctl list_queues Listing queues … 注:此时没有队列 清除队列里的消息 rabbitmqctl -p vhostpath purge_queue blue 命令行与管控台-高级操作 移除所有数据,要在rabbitmqctl stop_app之后使用 rabbitmqctl reset 组成集群命令 rabbitmqctl join_cluster [–ram] 查看集群状态 rabbitmqctl cluster_status 修改集群节点的储存形式 rabbitmqctl change_cluster_node_type disc|ram 忘记节点(摘除节点) rabbitmqctl forget_cluster_node [–offline] 修改节点名称 rabbitmqctl rename_cluster_node oldnode1 newnode1 [oldnode2] [newnode2…] 管控台-Overview项预览","categories":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://lylgjiavg.github.io/categories/消息中间件/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://lylgjiavg.github.io/tags/RabbitMQ/"},{"name":"消息中间件","slug":"消息中间件","permalink":"https://lylgjiavg.github.io/tags/消息中间件/"}]},{"title":"RabbitMQ安装及基本设置","slug":"RabbitMQ安装01","date":"2019-09-01T02:27:36.000Z","updated":"2019-09-02T02:27:19.317Z","comments":true,"path":"2019/09/01/RabbitMQ安装01/","link":"","permalink":"https://lylgjiavg.github.io/2019/09/01/RabbitMQ安装01/","excerpt":"","text":"安装环境摘要为了完整模拟RabbitMQ安装的从无到有,本次安装使用了VMware克隆了一个初始状态下的CentOS7镜像,下面介绍一下安装前的准备工作建议配置 更换阿里巴巴的yum仓库,便于下载所需文件: CentOS 1、备份 mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 2、下载新的CentOS-Base.repo 到/etc/yum.repos.d/ CentOS 7 wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 或者 curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 3、之后运行yum makecache生成缓存 具体可参考阿里巴巴镜像站 更换主机名 进入主机名配置文件,并修改主机名(在安装RabbitMQ后RabbitMQ会使用主机名,建议配置) *vim /etc/hostname * 本机修改为Jiavg RabbitMQ安装步骤1.创建下载文件所需的文件夹 [root@Jiavg /]# mkdir -p /usr/local/software/ [root@Jiavg /]# cd /usr/local/software/ [root@Jiavg software]# 2.下载所需文件 下载erlang和rabbitmq-server的rpm: [root@Jiavg software]#wget http://www.rabbitmq.com/releases/erlang/erlang-19.0.4-1.el7.centos.x86_64.rpm [root@Jiavg software]#wget http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.6/rabbitmq-server-3.6.6-1.el7.noarch.rpm 验证文件是否下载成功 [root@Jiavg software]# ls erlang-19.0.4-1.el7.centos.x86_64.rpm rabbitmq-server-3.6.6-1.el7.noarch.rpm 3.安装Erlang 安装erlang [root@Jiavg software]#rpm -ivh erlang-19.0.4-1.el7.centos.x86_64.rpm 验证erlang是否安装成功 [root@Jiavg software]# erl Erlang/OTP 19 [erts-8.0.3] [source] [64-bit] [smp:2:2] [async-threads:10] [hipe] [kernel-poll:false] Eshell V8.0.3 (abort with ^G) 1&gt; 4.安装RabbitMQ 安装socat(安装RabbitMQ需要此命令进行密匙校验) [root@Jiavg software]# yum install socat 如果不安装socat,则会出现以下情况: [root@Jiavg software]# rpm -ivh rabbitmq-server-3.6.6-1.el7.noarch.rpm 警告：rabbitmq-server-3.6.6-1.el7.noarch.rpm: 头V4 RSA/SHA1 Signature, 密钥 ID 6026dfca: NOKEY 错误：依赖检测失败： socat 被 rabbitmq-server-3.6.6-1.el7.noarch 需要 安装RabbitMQ [root@Jiavg software]# rpm -ivh rabbitmq-server-3.6.6-1.el7.noarch.rpm 警告：rabbitmq-server-3.6.6-1.el7.noarch.rpm: 头V4 RSA/SHA1 Signature, 密钥 ID 6026dfca: NOKEY 准备中… ################################# [100%] 正在升级/安装… 1:rabbitmq-server-3.6.6-1.el7 ################################# [100%] 5.修改基本配置文件 进入RabbitMQ配置文件目录 [root@Jiavg ebin]# cd /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.6/ebin/ 修改rabbit.app文件 [root@Jiavg ebin]#vim rabbit.app 在vim中使用/loopback定位需要修改的文件位置 /loopback 文件被定位到 {loopback_users, [&lt;&lt;”guest”&gt;&gt;]}, 修改为 {loopback_users, [guest]}, 即:删除&lt;&lt;”和”&gt;&gt; 保存并退出 6.安装RabbitMQ的rabbitmq_management插件 RabbitMQ的rabbitmq_management插件可以通过浏览器的可视化界面来管理RabbitMQ 启动RabbitMQ [root@Jiavg ebin]# rabbitmq-server start &amp; [1] 9843 [root@Jiavg ebin]# RabbitMQ 3.6.6. Copyright (C) 2007-2016 Pivotal Software, Inc. ## ## Licensed under the MPL. See http://www.rabbitmq.com/ ## ## ########## Logs: /var/log/rabbitmq/rabbit@Jiavg.log ###### ## /var/log/rabbitmq/rabbit@Jiavg-sasl.log ########## Starting broker... 查看本地可用插件 [root@Jiavg ebin]# rabbitmq-plugins list Configured: E = explicitly enabled; e = implicitly enabled | Status: [failed to contact rabbit@Jiavg - status not shown] |/ [ ] amqp_client 3.6.6 [ ] cowboy 1.0.3 [ ] cowlib 1.0.1 [ ] mochiweb 2.13.1 [ ] rabbitmq_amqp1_0 3.6.6 [ ] rabbitmq_auth_backend_ldap 3.6.6 [ ] rabbitmq_auth_mechanism_ssl 3.6.6 [ ] rabbitmq_consistent_hash_exchange 3.6.6 [ ] rabbitmq_event_exchange 3.6.6 [ ] rabbitmq_federation 3.6.6 [ ] rabbitmq_federation_management 3.6.6 [ ] rabbitmq_jms_topic_exchange 3.6.6 [ ] rabbitmq_management 3.6.6 [ ] rabbitmq_management_agent 3.6.6 [ ] rabbitmq_management_visualiser 3.6.6 [ ] rabbitmq_mqtt 3.6.6 [ ] rabbitmq_recent_history_exchange 1.2.1 [ ] rabbitmq_sharding 0.1.0 [ ] rabbitmq_shovel 3.6.6 [ ] rabbitmq_shovel_management 3.6.6 [ ] rabbitmq_stomp 3.6.6 [ ] rabbitmq_top 3.6.6 [ ] rabbitmq_tracing 3.6.6 [ ] rabbitmq_trust_store 3.6.6 [ ] rabbitmq_web_dispatch 3.6.6 [ ] rabbitmq_web_stomp 3.6.6 [ ] rabbitmq_web_stomp_examples 3.6.6 [ ] sockjs 0.3.4 [ ] webmachine 1.10.3 安装rabbitmq_management插件 [root@Jiavg ebin]# rabbitmq-plugins enable rabbitmq_management 7.测试RabbitMQ的rabbitmq_management插件 使用浏览器访问 IP地址:15672 把IP地址替换为你的RabbitMQ安装的主机IP 注意:如果不能正常访问,可能是防火墙问题 此时需要开启15672端口的访问权限 如以上步骤都正确,则浏览器会显示以下页面 在对应的输入框输入如下 Username:guest Password:guest 即:用户名和密码都是guest,这是RabbitMQ默认的账号和密码 在成功输入账户和密码后会进入如下界面 此时,RabbitMQ已经安装完成.","categories":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://lylgjiavg.github.io/categories/消息中间件/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://lylgjiavg.github.io/tags/RabbitMQ/"},{"name":"消息中间件","slug":"消息中间件","permalink":"https://lylgjiavg.github.io/tags/消息中间件/"}]},{"title":"RabbitMQ特点","slug":"RabbitMQ","date":"2019-08-31T23:48:15.000Z","updated":"2019-09-02T02:29:36.332Z","comments":true,"path":"2019/09/01/RabbitMQ/","link":"","permalink":"https://lylgjiavg.github.io/2019/09/01/RabbitMQ/","excerpt":"","text":"初识RabbitMQRabbitMQ是一个开源的消息代理和队列服务器,用来通过普通协议在完全不同的应用之间共享数据,RabbitMQ是使用Erlang语言来编写的,并且RabbitMQ是基于AMQP协议的.RabbitMQ优点 开源,性能优秀,稳定性保障 提供可靠性消息投递模式(confirm),返回模式(return) 与SpringAMQP完美整合,API丰富 集群模式丰富,表达式配置,HA(High Available)模式,镜像队列模型 保证数据不丢失的前提下做到高可靠性,可用性 RabbitMQ高性能原因? Erlang语言最初在于交换机领域的架构模式,这样使得RabbitMQ在Broker之间进行数据交互的性能是非常优秀的 Erlang优点:Erlang和原生Socket一样的延迟 什么是AMQP高级消息队列协议? AMQP全称:Advanced Message Queuing Protocol AMQP定义:是具有现代特征的二进制协议.是一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计. AMQP核心概念 Server:又称Broker,接受客户端的连接,实现AMQP实体服务 Connection:连接,应用程序与Broker的网络连接 Channel:网络信道,几乎所有的操作都在Channel在进行,Channel是进行消息的读写的通道.客户端可建立多个Channel,每个Channel代表一个会话任务. Message:消息,服务器与应用程序之间传送的数据,由Properties和Body组成.Properties可以对消息进行修饰,比如消息的优先级,延迟等高级特性;Body则就是消息体内容. Virtual host:虚拟地址,用于进行逻辑分离,最上层的消息路由.一个Virtual Host里面可以有若干个Exchange和Queue,同一个Virtual Host里面不能有相同名称的Exchange或Queue. Exchange:交换机,接收消息,根据路由键转发消息到绑定的队列. Binding:Exchange和Queue之间的虚拟连接,binding中可以包含routing key Routing key:一个路由规则,虚拟机可以用它来确定如何路由一个特定消息 Queue:也称Message Queue,消息队列,保存消息并将它们转发给消费者. RabbitMQ架构图","categories":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://lylgjiavg.github.io/categories/消息中间件/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://lylgjiavg.github.io/tags/RabbitMQ/"},{"name":"消息中间件","slug":"消息中间件","permalink":"https://lylgjiavg.github.io/tags/消息中间件/"}]},{"title":"牛客网刷题01","slug":"NewCoder-19-8-20","date":"2019-08-20T12:43:14.000Z","updated":"2019-09-02T02:28:01.934Z","comments":true,"path":"2019/08/20/NewCoder-19-8-20/","link":"","permalink":"https://lylgjiavg.github.io/2019/08/20/NewCoder-19-8-20/","excerpt":"","text":"1.若在某一个类定义中定义有如下的方法： abstract void performDial( ); 该方法属于（） A.本地方法 B.最终方法 C.解态方法 D.抽象方法 正确答案: D 解析: 本地方法：简单地讲，一个native Method就是一个java调用非java代码的接口；native方法表示该方法要用另外一种依赖平台的编程语言实现。 最终方法：final void B(){},这样定义的方法就是最终方法，最终方法在子类中不可以被重写，也就是说，如果有个子类继承了这个最终方法所在的类，那么这个子类中不能出现void B(){}这样的方法。 最终类：final class A {},这样定义的类就是最终类，最终类不能被继承。 abstract修饰抽象类 2.当使包含 applet 程序的页面从最小化恢复时，以下选项中的哪个方法将被执行？（ ） A.paint() B.start() C.destroy() D.stop() 正确答案: A 解析: applet页面刚打开时,程序调用init(),然后调用start(),再然后paint(); 用户离开applet页面,程序自动调用stop(),用户关闭浏览器,程序触发destroy(); 并且paint()在每一次浏览器显示页面时被调用; 最小化点开-->页面重新显示，之前进程没丢，只有paint()。 3.下列关于修饰符混用的说法，错误的是( ) A.abstract不能与final并列修饰同一个类 B.abstract类中不应该有private的成员 C.abstract方法必须在abstract类或接口中 D.static方法中能直接调用类里的非static的属性","categories":[{"name":"nowcoder","slug":"nowcoder","permalink":"https://lylgjiavg.github.io/categories/nowcoder/"}],"tags":[{"name":"牛客网","slug":"牛客网","permalink":"https://lylgjiavg.github.io/tags/牛客网/"}]},{"title":"Docker基本使用","slug":"Docker","date":"2019-08-17T12:09:32.000Z","updated":"2019-08-17T16:04:53.304Z","comments":true,"path":"2019/08/17/Docker/","link":"","permalink":"https://lylgjiavg.github.io/2019/08/17/Docker/","excerpt":"","text":"Docker描述 Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到 任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。Docker安装进入yum目录 [root@bogon yum.repos.d]cd /etc/yum.repos.d/ 下载repo [root@bogon yum.repos.d]# wget https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo --2019-08-17 21:23:14-- https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo 正在解析主机 mirrors.tuna.tsinghua.edu.cn (mirrors.tuna.tsinghua.edu.cn)... 101.6.8.193, 2402:f000:1:408:8100::1 正在连接 mirrors.tuna.tsinghua.edu.cn (mirrors.tuna.tsinghua.edu.cn)|101.6.8.193|:443... 已连接。 已发出 HTTP 请求，正在等待回应... 200 OK 长度：2424 (2.4K) [application/octet-stream] 正在保存至: “docker-ce.repo” 100%[==========================================================================================================>] 2,424 --.-K/s 用时 0s 2019-08-17 21:23:14 (262 MB/s) - 已保存 “docker-ce.repo” [2424/2424]) 验证docker-ce是否安装成功 [root@bogon yum.repos.d]# ls CentOS-Base.repo CentOS-Debuginfo.repo CentOS-Media.repo CentOS-Vault.repo CentOS-CR.repo CentOS-fasttrack.repo CentOS-Sources.repo docker-ce.repo [root@bogon yum.repos.d]# yum repolist 已加载插件：fastestmirror, langpacks Loading mirror speeds from cached hostfile * base: mirrors.njupt.edu.cn * extras: mirrors.cn99.com * updates: mirrors.cn99.com 源标识 源名称 状态 base/7/x86_64 CentOS-7 - Base 10,019 docker-ce-stable/x86_64 Docker CE Stable - x86_64 52 extras/7/x86_64 CentOS-7 - Extras 435 updates/7/x86_64 CentOS-7 - Updates 2,500 repolist: 13,006 [root@bogon yum.repos.d]# docker --version Docker version 19.03.1, build 74b1e89 配置Docker加速器Json[root@bogon yum.repos.d]# mkdir /etc/docker/ [root@bogon yum.repos.d]# vi /etc/docker/daemon.json 在daemon.json 中添加 { &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;] } 测试Docker创建一个httpd服务获得busybox镜像 [root@bogon yum.repos.d]# docker image pull busybox 利用busybox创建一个容器 [root@bogon yum.repos.d]# docker container run --name myhttpd -it busybox 创建httpd工作目录及index.html / # mkdir /data/html -p / # vi /data/html/index.html 在index.html添加&quot;Hello Docker!&quot; 此时此进程处于阻塞状态,然后再启动另一个Shell进程 使用docker inspect myhttpd命令查看myhttpd容器的状态信息 [root@bogon ~]# docker inspect myhttpd [ { ..., ..., &quot;NetworkSettings&quot;: { ..., ... &quot;Networks&quot;: { &quot;bridge&quot;: { &quot;IPAMConfig&quot;: null, &quot;Links&quot;: null, &quot;Aliases&quot;: null, &quot;NetworkID&quot;: &quot;c28b3cad37536a90abf27043b6b2caa931bcd31ec79b0785d92ee00236a8f575&quot;, &quot;EndpointID&quot;: &quot;7dedddc84a36d48c4d6d78773cb571179bd455704cb5c341e6fa43764a2dac0d&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot;, &quot;IPAddress&quot;: &quot;172.17.0.4&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:04&quot;, &quot;DriverOpts&quot;: null } } } } ] 在NetworkSettings下的IPAddress可以获得myhttpd的容器虚拟地址为172.17.0.4 此时使用curl命令来验证httpd服务是否进行 [root@bogon ~]# curl 172.17.0.4 Hello Docker! 可以观察到myhttpd容器内的httpd服务正常运行附:Docker生命周期","categories":[{"name":"容器引擎","slug":"容器引擎","permalink":"https://lylgjiavg.github.io/categories/容器引擎/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://lylgjiavg.github.io/tags/Docker/"},{"name":"container","slug":"container","permalink":"https://lylgjiavg.github.io/tags/container/"}]},{"title":"ArrayList","slug":"ArrayList","date":"2019-08-14T14:28:50.000Z","updated":"2019-08-14T14:57:40.566Z","comments":true,"path":"2019/08/14/ArrayList/","link":"","permalink":"https://lylgjiavg.github.io/2019/08/14/ArrayList/","excerpt":"","text":"ArrayList类继承关系 IDEA使用Ctrl+Shift+Alt+N快捷键查找此类 ArrayList类继承关系如下图所示: ![ArrayList继承关系图](https://i.imgur.com/nTyDgMV.jpg)Iterable接口 Implementing this interface allows an object to be the target of the “for-each loop” statement. 即:实现这个接口允许对象成为“for-each循环”语句的目标。 而java.util.Collection接口继承java.lang.Iterable，故标准类库中的任何集合都可以使用for-each循环。 为什么一定要去实现Iterable这个接口呢？ 为什么不直接实现Iterator接口呢？看一下JDK中的集合类，比如List一族或者Set一族，都是继承了Iterable接口，但并不直接继承Iterator接口。仔细想一下这么做是有道理的。因为Iterator接口的核心方法next()或者hasNext()是依赖于迭代器的当前迭代位置的。如果Collection直接继承Iterator接口，势必导致集合对象中包含当前迭代位置的数据(指针)。当集合在不同方法间被传递时，由于当前迭代位置不可预置，那么next()方法的结果会变成不可预知。除非再为Iterator接口添加一个reset()方法，用来重置当前迭代位置。但即时这样，Collection也只能同时存在一个当前迭代位置。而Iterable则不然，每次调用都会返回一个从头开始计数的迭代器。多个迭代器是互不干扰的。","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://lylgjiavg.github.io/categories/数据结构和算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lylgjiavg.github.io/tags/数据结构/"}]},{"title":"插入排序","slug":"插入排序-递归+二分查找","date":"2019-07-21T01:58:02.000Z","updated":"2019-07-21T02:09:53.477Z","comments":true,"path":"2019/07/21/插入排序-递归+二分查找/","link":"","permalink":"https://lylgjiavg.github.io/2019/07/21/插入排序-递归+二分查找/","excerpt":"","text":"题目：leetcode(912): 给定一个整数数组 nums，将该数组升序排列。 示例 1： 输入：[5,2,3,1] 输出：[1,2,3,5] 示例 2： 输入：[5,1,1,2,0,0] 输出：[0,0,1,1,2,5] 提示： 1 &lt;= A.length &lt;= 10000 -50000 &lt;= A[i] &lt;= 50000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sort-an-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路: (稍后总结) 具体代码:class Solution { public int[] sortArray(int[] nums) { if(nums == null || nums.length == 1){ return nums; } for(int currentInsetIndex = 1; currentInsetIndex &lt; nums.length; currentInsetIndex++){ // currentInset:当前进行插入的数字 int currentInset = nums[currentInsetIndex]; // 当前进行比较的下标 int currentCompareIndex = currentInsetIndex - 1; // 二分查找到正确位置 int index = Solution.binarySearch(nums, 0, currentCompareIndex, currentInset); // 在正确位置进行插入 Solution.insertNum(nums, 0, currentInsetIndex, index); } return nums; } /** * 二分查找数值在已排序数组中正确的下标 * @param array 进行查找的数组 * @param lower 查找下界 * @param up 查找上界 * @param num 查找数字 * @return 下标 */ public static int binarySearch(int[] array, int lower, int up, int num){ int lowerSearch = lower; int upSearch = up; int middle = (upSearch - lowerSearch)/2 + lowerSearch; while(lowerSearch &lt;= upSearch){ if(array[middle] > num){ upSearch = middle - 1; }else{ lowerSearch = middle + 1; } middle = (upSearch - lowerSearch)/2 + lowerSearch; } return middle; } /** * 插入值到数组中(数组范围内的一个数插入到本数组的另一个位置) * @param array 进行插入的数组 * @param lower 插入范围下界 * @param up 插入范围上界(也是要进行插入的值) * @param index 插入下标 */ public static void insertNum(int[] array, int lower, int up, int index){ // unlawfulness if(up &lt;= index &amp;&amp; index &lt; lower){ return; } // save a value of insert int num = array[up]; // move inserted value of last to last for (int i = up; i > index &amp;&amp; i > lower; i--){ array[i] = array[i-1]; } // insert value array[index] = num; } } 运行结果:执行结果： 通过 显示详情 执行用时 : 314 ms, 在所有 Java 提交中击败了8.58%的用户 内存消耗 : 52.1 MB, 在所有 Java 提交中击败了100.00%的用户 结果分析: 本来对这个算法寄予了很大期望: 1.利用二分查找法解决了进行线性查找而需要的线性时间,进而把查找时间压缩到了lg(n). 2.利用迭代替换掉递归,进而解决了在数组长度过大时出现的java.lang.StackOverflowError 对于第一次用算法结合的方式进行排序冷静分析后: 1.对于内存消耗还是很好理解,原址排序. 2.对于执行用时,虽然用二分查找法代替掉了线性查找,但还是改变不了算法本身是插入排序,而对于插入排序最忌惮的就是数组长度.","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://lylgjiavg.github.io/categories/数据结构和算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://lylgjiavg.github.io/tags/LeetCode/"},{"name":"算法导论","slug":"算法导论","permalink":"https://lylgjiavg.github.io/tags/算法导论/"}]},{"title":"插入排序(递归实现)","slug":"插入排序-递归实现","date":"2019-07-20T02:18:26.000Z","updated":"2019-07-20T02:47:08.048Z","comments":true,"path":"2019/07/20/插入排序-递归实现/","link":"","permalink":"https://lylgjiavg.github.io/2019/07/20/插入排序-递归实现/","excerpt":"","text":"题目：leetcode(912): 给定一个整数数组 nums，将该数组升序排列。 示例 1： 输入：[5,2,3,1] 输出：[1,2,3,5] 示例 2： 输入：[5,1,1,2,0,0] 输出：[0,0,1,1,2,5] 提示： 1 &lt;= A.length &lt;= 10000 -50000 &lt;= A[i] &lt;= 50000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sort-an-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路: (稍后总结) 具体代码: public static void insertionSort(int[] array, int lower, int up){ // 合并 if(lower &lt; up){ // 分解 insertionSort(array, lower, up - 1); // 解决 int index = lineSearch(array, lower, up -1, array[up]); insertNum(array, lower, up, index); } } /** * 线性查找数值在已排序数组中正确的下标 * @param array 进行查找的数组 * @param lower 查找下界 * @param up 查找上界 * @param num 查找数字 * @return 下标 */ public static int lineSearch(int[] array, int lower, int up, int num){ for(int i = up; i >= lower; i--){ if(array[i] &lt; num){ return i + 1; } } return lower; } /** * 插入值到数组中(数组范围内的一个数插入到本数组的另一个位置) * @param array 进行插入的数组 * @param lower 插入范围下界 * @param up 插入范围上界(也是要进行插入的值) * @param index 插入下标 */ public static void insertNum(int[] array, int lower, int up, int index){ // unlawfulness if(up &lt;= index &amp;&amp; index &lt; lower){ return; } // save a value of insert int num = array[up]; // move inserted value of last to last for (int i = up; i > index &amp;&amp; i > lower; i--){ array[i] = array[i-1]; } // insert value array[index] = num; } 运行结果:执行结果： 超出时间限制 显示详情 最后执行的输入： [5864,-12333,4151,-6239,-10306,10866,-7013,13195,-8855,1150,-560,3227,10387,-2329,5169,-19527...] 显示详情: 提交记录 9 / 10 个通过测试用例 状态：超出时间限制 结果分析: 对于这个结果很诧异也在情理之中,对于算法本身没有什么问题,LeetCode应该是检测到消耗的资源和时间太多才会显示这个结果(9 / 10 个通过测试用例,1 &lt;= A.length &lt;= 10000,-50000 &lt;= A[i] &lt;= 50000).而本身自己也做了一个测试,测试代码如下: public static void main(String[] args) { int[] array = new int[10000]; Random rand = new Random(); for (int i = 0; i &lt; 10000; i++){ array[i] = rand.nextInt(10000) - 5000; } insertionSort(array, 0, array.length - 1); System.out.printf(array.toString()); } 而对于结果则是没有什么问题的.我在接下来,则会用二分查找法进行查找要插入的下标,大大减少查询所用时间,相信将不会出现超出时间限制这个结果. 附:--------------------- 插入排序的特点: 1.对于少量元素的排序,他是一个有效的算法 2.原址排序 递归和迭代特点: 使用场景： 需要重复地多次地计算相同的问题，一般会用到递归和循环。 递归： 概念：内部调用函数本身。 使用前提： 在使用递归的时候，必须有一个明确的递归结束条件，称之为递归出口。 使用递归，必须预期收敛。 迭代： 通过设置初始条件和结束条件，在一个范围内重复计算。 代码的可读性不如递归，但是效率更高。 递归的优点： 1. 代码简洁； 2. 在树的前序，中序，后序的遍历算法中，递归的实现比循环简单很多。 递归的缺点： 1. 时间和空间的消耗比较大。 每一个线程都会有一个私有的栈mixed stack，存储java方法的桢栈和native方法的桢栈。每一次方法的调用都涉及到一个桢栈的入栈到出栈。同时，会涉及到分配内存空间，保存参数，返回地址和临时变量，而且往栈里压入数据和弹出都需要时间。 2. 递归会出现重复计算。 递归的本质是把一个问题分解为多个问题，如果多个问题存在重复计算，有时候这个情况会随着n成指数增长。比如斐波那契的递归就是一个例子。 3. 递归还有栈溢出的问题，每个线程的栈容量多少有限的。 如果栈内存没有可用空间存储方法桢栈（包括局部变量表，操作数栈，返回地址，动态链接），jvm会抛出java.lang.StackOverFlowError. 栈的内存远远小于堆内存，-Xss选项设置栈内存大小，-Xms设置堆开始的大小，-Xmx堆最大值.(ps：如果是堆内存没有可用空间存储生成对象，jvm会抛出java.lang.OutOfMemoryError.) 迭代的速度快，那么递归存在的意义呢？ 理论上来说，所有的递归函数都可以转换为迭代函数，反之亦然。但是一般来说，代价比较高。 实际上来说，迭代都可以转换为递归，但是递归不一定能转换为迭代。 --------------------- 作者：YY_worhol 来源：CSDN 原文：https://blog.csdn.net/YY_worhol/article/details/83617109 版权声明：本文为博主原创文章，转载请附上博文链接！","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://lylgjiavg.github.io/categories/数据结构和算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://lylgjiavg.github.io/tags/LeetCode/"},{"name":"算法导论","slug":"算法导论","permalink":"https://lylgjiavg.github.io/tags/算法导论/"}]},{"title":"归并排序","slug":"归并排序","date":"2019-07-19T13:16:15.000Z","updated":"2019-07-19T13:28:05.914Z","comments":true,"path":"2019/07/19/归并排序/","link":"","permalink":"https://lylgjiavg.github.io/2019/07/19/归并排序/","excerpt":"","text":"题目：leetcode(912): 给定一个整数数组 nums，将该数组升序排列。 示例 1： 输入：[5,2,3,1] 输出：[1,2,3,5] 示例 2： 输入：[5,1,1,2,0,0] 输出：[0,0,1,1,2,5] 提示： 1 &lt;= A.length &lt;= 10000 -50000 &lt;= A[i] &lt;= 50000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sort-an-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路: (稍后总结：TODO) 具体代码:class Solution { public int[] sortArray(int[] nums) { Solution.mergeSort(nums, 0, nums.length - 1); return nums; } public static void mergeSort(int arr[], int lower, int up){ if(lower &lt; up){ int middleLeft = (up - lower)/2 + lower; int middleRight = middleLeft + 1; mergeSort(arr, lower, middleLeft); mergeSort(arr, middleRight, up); merge(arr, lower, middleLeft, up); } } public static void merge(int arr[], int lower, int middle, int up){ // lower ~ middle int leftLength = middle - lower + 1; // middle+1 ~ up int rightLength = up - middle; // +1是为了在最底层存放一个最大的数字,可以使本数组元素抽取完毕后不断把另一个数组元素抽取 int[] leftArr = new int[leftLength + 1]; int[] rightArr = new int[rightLength + 1]; for(int i = 0; i &lt; leftLength; i++){ leftArr[i] = arr[lower + i]; } for(int i = 0; i &lt; rightLength; i++){ rightArr[i] = arr[middle + i + 1]; } leftArr[leftLength] = Integer.MAX_VALUE; rightArr[rightLength] = Integer.MAX_VALUE; int l = 0; int r = 0; for(int j = 0; j &lt; (up - lower + 1); j++){ if(leftArr[l] &lt; rightArr[r]){ arr[lower + j] = leftArr[l]; l++; }else{ arr[lower + j] = rightArr[r]; r++; } } } } 运行结果:执行结果：通过 显示详情 执行用时 : 17 ms, 在所有 Java 提交中击败了48.93%的用户 内存消耗 : 50.4 MB, 在所有 Java 提交中击败了100.00%的用户 结果分析:由归并排序的特点: 1.采用了分治思想，该算法最坏情况运行时间比插入排序（增量方法）要少得多。 2.归并排序将原问题分解成几个规模较小的但类似于原问题的子问题，递归的求这些子问题，然后合并这些子问题的解来建立原问题的解（这就是分治思想的特点）。 分析可得: （稍后分析：TODO）","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://lylgjiavg.github.io/categories/数据结构和算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://lylgjiavg.github.io/tags/LeetCode/"},{"name":"算法导论","slug":"算法导论","permalink":"https://lylgjiavg.github.io/tags/算法导论/"}]},{"title":"插入排序","slug":"插入排序","date":"2019-07-19T02:17:55.000Z","updated":"2019-07-19T07:25:49.001Z","comments":true,"path":"2019/07/19/插入排序/","link":"","permalink":"https://lylgjiavg.github.io/2019/07/19/插入排序/","excerpt":"","text":"题目：leetcode(912): 给定一个整数数组 nums，将该数组升序排列。 示例 1： 输入：[5,2,3,1] 输出：[1,2,3,5] 示例 2： 输入：[5,1,1,2,0,0] 输出：[0,0,1,1,2,5] 提示： 1 &lt;= A.length &lt;= 10000 -50000 &lt;= A[i] &lt;= 50000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sort-an-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路: (稍后总结) 具体代码:public int[] sortArray(int[] nums) { if(nums == null || nums.length == 1){ return nums; } for(int currentInsetIndex = 1; currentInsetIndex &lt; nums.length; currentInsetIndex++){ int currentInset = nums[currentInsetIndex]; int currentCompareIndex = currentInsetIndex - 1; while(currentCompareIndex >= 0 &amp;&amp; nums[currentCompareIndex] > currentInset){ nums[currentCompareIndex + 1] = nums[currentCompareIndex]; currentCompareIndex--; } nums[currentCompareIndex + 1] = currentInset; } return nums; } 运行结果:执行结果：通过 显示详情 执行用时 : 407 ms, 在所有 Java 提交中击败了5.04%的用户 内存消耗 : 51.5 MB, 在所有 Java 提交中击败了100.00%的用户 结果分析:由插入排序的特点: 1.对于少量元素的排序,他是一个有效的算法 2.原址排序 分析可得: 1.由于每次插入都需要与前面已经排序好的进行比较,最坏情况下需要比较n次(n为每次插入已排序好的数组元素值),故对于10000这个数量的数组大小,插入排序表现得情况很差. 2.由于插入排序进行原址排序,故内存消耗表现非常完美.","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://lylgjiavg.github.io/categories/数据结构和算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://lylgjiavg.github.io/tags/LeetCode/"},{"name":"算法导论","slug":"算法导论","permalink":"https://lylgjiavg.github.io/tags/算法导论/"}]},{"title":"两两交换链表中的节点(Swap Nodes in Pairs)","slug":"两两交换链表中的节点-Swap-Nodes-in-Pairs","date":"2019-06-30T12:14:54.000Z","updated":"2019-07-04T10:08:10.195Z","comments":true,"path":"2019/06/30/两两交换链表中的节点-Swap-Nodes-in-Pairs/","link":"","permalink":"https://lylgjiavg.github.io/2019/06/30/两两交换链表中的节点-Swap-Nodes-in-Pairs/","excerpt":"","text":"题目描述:给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。示例: 给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.链表类: class ListNode{ int val; ListNode next; ListNode(int x){ val = x; } } 解题思路:注意:在进行交换时:要保证链表的各个部分的引用均不被丢弃. (一般情况) 情况一(绿色线段表示):当两两交换的链表处于链表的第一和第二位置步骤一:保存奇数节点(节点3)的引用;步骤二:保存偶数节点(节点4)的引用;是步骤四的前提,如果不保存,步骤三过后节点4的引用将被丢弃.(步骤三和步骤四不可调换,否则需要额外的内存(引用)来保存节点5的引用信息)步骤三:节点3.next=节点5;步骤四:节点4.next=节点3; (特殊情况)情况二(黑色线段表示):当两两交换的链表不是处于链表的第一和第二位置步骤一:保存奇数节点(节点1)的引用;步骤二:保存偶数节点(节点2)的引用;与情况一不同的是:保存偶数节点的引用为交换后链表的头引用,而不能是情况一的中间变量,否则中间变量在进行下一重循环而重新赋值后,交换后的链表头的引用将被丢弃.(步骤三和步骤四不可调换,否则需要额外的内存(引用)来保存节点3的引用信息)步骤三:节点1.next=节点3;步骤四:节点2.next=节点1; 具体代码1:public ListNode swapPairs(ListNode head) { // 非空验证 if(head == null || head.next == null){ return head; } // 交换结果链表头引用 ListNode reverse = head; // 当前交换位置 ListNode current = head; // 两两交换的前一链表的引用(使已交换的链表指向刚交换好的链表节点) ListNode forSwap = null; while(current != null){ // 如果总链表的节点数为奇数,则最后那个节点就没必要进行交换 if(current.next != null){ /********步骤一********/ ListNode odd = current; /********步骤二********/ // 情况一 if(forSwap != null){ forSwap.next = odd.next; } // 情况二 if(current == head){ reverse = odd.next; } /********步骤三********/ odd.next = odd.next.next; /********步骤四********/ if(forSwap != null) { // 情况一 forSwap.next.next = odd; }else{ // 情况二 reverse.next = odd; } // 更新要交换的下两个节点信息 current = odd.next; forSwap = odd; }else { return reverse; } } return reverse; } 在LeetCode运行的结果:成功 显示详情 执行用时 : 1 ms, 在Swap Nodes in Pairs的Java提交中击败了94.04% 的用户 内存消耗 : 34.1 MB, 在Swap Nodes in Pairs的Java提交中击败了88.92% 的用户 来自 &lt;https://leetcode-cn.com/problems/swap-nodes-in-pairs/submissions/&gt; 具体代码2:(思路和代码1相同,只不过两两交换的第二个节点用了额外的变量进行保存,但运行情况却比较代码1好一点,我不明白的是明明引用少了一个,为什么内存消耗为什么反而减小?初学算法,请多多指教) public ListNode swapPairs(ListNode head) { // 非空验证 if(head == null || head.next == null){ return head; } ListNode reverse = head; ListNode current = head; ListNode forSwap = null; while(current != null){ if(current.next != null){ /********步骤一********/ ListNode odd = current; /********步骤二********/ ListNode even = odd.next; if(current == head){ reverse = even; } /********步骤三********/ odd.next = even.next; /********步骤四********/ even.next = odd; // 链接到已交换的链表后 if(forSwap != null){ forSwap.next = even; } current = odd.next; forSwap = odd; }else { return reverse; } } return reverse; } 在LeetCode运行的结果:成功 显示详情 执行用时 : 1 ms, 在Swap Nodes in Pairs的Java提交中击败了94.04% 的用户 内存消耗 : 33.9 MB, 在Swap Nodes in Pairs的Java提交中击败了90.90% 的用户 来自 [LeetCode](https://leetcode-cn.com/problems/swap-nodes-in-pairs/submissions/) 附:不知道LeetCode运行时会不会受到当时服务器的速度影响,还是LeetCode针对提交的代码有一套自己对时间复杂度和空间复杂度有一套自己的算法,总感觉提交后有些许不同.​​","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://lylgjiavg.github.io/categories/数据结构和算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://lylgjiavg.github.io/tags/LeetCode/"}]},{"title":"基于腾讯云的COS存储静态资源","slug":"基于腾讯云的COS存储静态资源","date":"2019-06-30T02:03:17.000Z","updated":"2019-09-10T15:31:12.616Z","comments":true,"path":"2019/06/30/基于腾讯云的COS存储静态资源/","link":"","permalink":"https://lylgjiavg.github.io/2019/06/30/基于腾讯云的COS存储静态资源/","excerpt":"","text":"对象存储 COS 简介 对象存储（Cloud Object Storage，COS）是由腾讯云推出的无目录层次结构、无数据格式限制，可容纳海量数据且支持 HTTP/HTTPS 协议访问的分布式存储服务。腾讯云 COS 的存储桶空间无容量上限，无需分区.管理，适用于 CDN 数据分发、数据万象处理或大数据计算与分析的数据湖等多种场景。COS 提供网页端管理界面、多种主流开发语言的 SDK、API 以及命令行和图形化工具，并且兼容 S3 的 API 接口，方便用户直接使用社区工具和插件。 COS作用可以利用对象存储（Cloud Object Storage，COS）来管理我们的博客静态资源,如图片、音乐、以及html、css、js等。个人主要利用COS来管理图片、音乐文件,因为自己博客是发布在GitHub上,所以访问速度受限,而把这些静态文件存储在COS服务上则可以加快博客的加载速度. 利用腾讯云的COS管理静态资源步骤： 1.注册腾讯云账户&nbsp;&nbsp;&nbsp;&nbsp;注册腾讯云并使用COS服务是完全免费的,其中,注册地址为:腾讯云. 2.申请COS服务&nbsp;&nbsp;&nbsp;&nbsp;申请COS服务地址为:COS申请 3.创建存储桶&nbsp;&nbsp;&nbsp;&nbsp;在进入步骤2网址后点击立即使用(个人开发不用购买资源包,使用免费的可以).然后创建储存桶,如下图所示.必填项为:名称注意:访问权限为:公有读私有写(如是默认的私有读写,则博客无法引用静态资源) 4.在存储桶创建文件夹并上传文件 5.进行基础配置点击基础配置项把静态网站的开关使处于开的状态.其中,索引文件不用在意,点击保存. 6.通过COS服务访问静态文件点击已上传的静态资源的详情项,便进入静态资源的信息页面,此时就可以Copy对象地址属性值,引用到你的博客中,完成显示. 附加:腾讯云COS官方应用场景 ####1.应用数据存储 无论是手机 APP、网站，或 HTML5 页面，对象存储可根据应用程序类型提供各语言 SDK，实现无缝接入。当业务爆发、用户产生内容（UGC）突增时，对象存储将根据请求和流量的需求自动扩展，从容应对业务突发访问状况。由于 UGC 通常具有时间维度级的访问特征，对象存储可将数据冷热分层，热数据使用标准存储，冷数据使用低频存储。配合生命周期规则配置，转换存储类别，有效降低存储成本。 ####2.数据处理 对于用户传入 COS 的数据，COS 可结合腾讯云多种数据处理类产品对其进行编辑、处理和审核操作，针对图片数据，用户可结合 数据万象 对其进行裁剪、缩放、转码、锐化、添加水印等处理操作，还可以进行鉴黄、鉴政、鉴暴恐等内容审核；针对视频数据，用户可使用视频处理对其进行转码、水印、截帧等处理；针对文档数据，用户可利用数据万象生成文档的图片或 HTML 预览，并可对预览图添加水印。 ####3.内容分发 网站服务通常会在动态网页中，根据一定规则将经常变动和长期不变的资源区分开，静态资源就是指长期不变的非结构化数据资源。标准存储提供了静态资源的存储和分发能力，减轻资源服务器的压力，并利用无限容量、高频读写的特性，为静态资源提供可扩展和可靠的存储。用户可以将网站中的静态内容（包括音视频、图片等文件）全部托管在标准存储中，并利用腾讯云 CDN 分发内容。结合腾讯云 CDN 全球加速节点的能力，可以将热点文件提前下发至边缘节点，降低访问延迟。 ####4.大数据分析 无论用户存储的是医疗或财务方面的数据还是照片和音视频之类的多媒体文件，COS 都可以作为数据源进行大数据分析。对象存储支持存储 EB 级别非结构化数据，高可用、高可靠、高安全和可扩展性，结合使用腾讯云大数据套件，快速构建和部署分析应用程序。在高性能计算需求完成后，可以将数据转换为归档存储，降低服务使用成本，以便长期存储数据。 ####5.容灾及备份 用户放在对象存储上的数据可以通过跨区域复制功能同时存储在多个指定区域，保证在某些意外丢失部分数据的情况下仍能通过冗余数据来查找并恢复完整数据，同时，因为多份数据存放在不同的地区，因此能避免一个地区的存储受到不可抗逆灾难时会造成的损失，从而达到多冗余备份和异地容灾的效果，保证数据的持久性和稳定性，为重要数据加上多重保险。","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://lylgjiavg.github.io/categories/博客搭建/"}],"tags":[{"name":"COS","slug":"COS","permalink":"https://lylgjiavg.github.io/tags/COS/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-06-29T12:51:02.577Z","updated":"2019-06-29T12:51:02.577Z","comments":true,"path":"2019/06/29/hello-world/","link":"","permalink":"https://lylgjiavg.github.io/2019/06/29/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}