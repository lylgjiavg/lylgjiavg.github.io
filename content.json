{"meta":{"title":"Jiavg","subtitle":"lylg-JLC","description":"个人技术总结","author":"Jiavg","url":"https://lylgjiavg.github.io","root":"/"},"pages":[{"title":"categories","date":"2018-09-30T09:25:30.000Z","updated":"2019-06-29T15:24:29.993Z","comments":true,"path":"categories/index.html","permalink":"https://lylgjiavg.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2019-06-29T15:25:35.750Z","comments":true,"path":"about/index.html","permalink":"https://lylgjiavg.github.io/about/index.html","excerpt":"","text":""},{"title":"friends","date":"2018-12-12T13:25:30.000Z","updated":"2019-06-29T15:26:00.186Z","comments":true,"path":"friends/index.html","permalink":"https://lylgjiavg.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-30T10:23:38.000Z","updated":"2019-06-29T15:25:03.807Z","comments":true,"path":"tags/index.html","permalink":"https://lylgjiavg.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"两两交换链表中的节点(Swap Nodes in Pairs)","slug":"两两交换链表中的节点-Swap-Nodes-in-Pairs","date":"2019-06-30T12:14:54.000Z","updated":"2019-07-01T04:41:10.115Z","comments":true,"path":"2019/06/30/liang-liang-jiao-huan-lian-biao-zhong-de-jie-dian-swap-nodes-in-pairs/","link":"","permalink":"https://lylgjiavg.github.io/2019/06/30/liang-liang-jiao-huan-lian-biao-zhong-de-jie-dian-swap-nodes-in-pairs/","excerpt":"","text":"题目描述:给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。示例: 给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.链表类: class ListNode{ int val; ListNode next; ListNode(int x){ val = x; } } 解题思路: 注意:在进行交换时:要保证链表的各个部分的引用均不被丢弃. (一般情况) 情况一(绿色线段表示):当两两交换的链表处于链表的第一和第二位置步骤一:保存奇数节点(节点3)的引用;步骤二:保存偶数节点(节点4)的引用;是步骤四的前提,如果不保存,步骤三过后节点4的引用将被丢弃.(步骤三和步骤四不可调换,否则需要额外的内存(引用)来保存节点5的引用信息)步骤三:节点3.next=节点5;步骤四:节点4.next=节点3; (特殊情况)情况二(黑色线段表示):当两两交换的链表不是处于链表的第一和第二位置步骤一:保存奇数节点(节点1)的引用;步骤二:保存偶数节点(节点2)的引用;与情况一不同的是:保存偶数节点的引用为交换后链表的头引用,而不能是情况一的中间变量,否则中间变量在进行下一重循环而重新赋值后,交换后的链表头的引用将被丢弃.(步骤三和步骤四不可调换,否则需要额外的内存(引用)来保存节点3的引用信息)步骤三:节点1.next=节点3;步骤四:节点2.next=节点1; 具体代码1:public ListNode swapPairs(ListNode head) { // 非空验证 if(head == null || head.next == null){ return head; } // 交换结果链表头引用 ListNode reverse = head; // 当前交换位置 ListNode current = head; // 两两交换的前一链表的引用(使已交换的链表指向刚交换好的链表节点) ListNode forSwap = null; while(current != null){ // 如果总链表的节点数为奇数,则最后那个节点就没必要进行交换 if(current.next != null){ /********步骤一********/ ListNode odd = current; /********步骤二********/ // 情况一 if(forSwap != null){ forSwap.next = odd.next; } // 情况二 if(current == head){ reverse = odd.next; } /********步骤三********/ odd.next = odd.next.next; /********步骤四********/ if(forSwap != null) { // 情况一 forSwap.next.next = odd; }else{ // 情况二 reverse.next = odd; } // 更新要交换的下两个节点信息 current = odd.next; forSwap = odd; }else { return reverse; } } return reverse; } 在LeetCode运行的结果:成功 显示详情 执行用时 : 1 ms, 在Swap Nodes in Pairs的Java提交中击败了94.04% 的用户 内存消耗 : 34.1 MB, 在Swap Nodes in Pairs的Java提交中击败了88.92% 的用户 来自 &lt;https://leetcode-cn.com/problems/swap-nodes-in-pairs/submissions/&gt; 具体代码2:(思路和代码1相同,只不过两两交换的第二个节点用了额外的变量进行保存,但运行情况却比较代码1好一点,我不明白的是明明引用少了一个,为什么内存消耗为什么反而减小?初学算法,请多多指教) public ListNode swapPairs(ListNode head) { // 非空验证 if(head == null || head.next == null){ return head; } ListNode reverse = head; ListNode current = head; ListNode forSwap = null; while(current != null){ if(current.next != null){ /********步骤一********/ ListNode odd = current; /********步骤二********/ ListNode even = odd.next; if(current == head){ reverse = even; } /********步骤三********/ odd.next = even.next; /********步骤四********/ even.next = odd; // 链接到已交换的链表后 if(forSwap != null){ forSwap.next = even; } current = odd.next; forSwap = odd; }else { return reverse; } } return reverse; } 在LeetCode运行的结果:成功 显示详情 执行用时 : 1 ms, 在Swap Nodes in Pairs的Java提交中击败了94.04% 的用户 内存消耗 : 33.9 MB, 在Swap Nodes in Pairs的Java提交中击败了90.90% 的用户 来自 [LeetCode](https://leetcode-cn.com/problems/swap-nodes-in-pairs/submissions/) 附:不知道LeetCode运行时会不会受到当时服务器的速度影响,还是LeetCode针对提交的代码有一套自己对时间复杂度和空间复杂度有一套自己的算法,总感觉提交后有些许不同.​​","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://lylgjiavg.github.io/categories/数据结构和算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://lylgjiavg.github.io/tags/LeetCode/"}]},{"title":"基于腾讯云的COS存储静态资源","slug":"基于腾讯云的COS存储静态资源","date":"2019-06-30T02:03:17.000Z","updated":"2019-06-30T03:12:51.228Z","comments":true,"path":"2019/06/30/ji-yu-teng-xun-yun-de-cos-cun-chu-jing-tai-zi-yuan/","link":"","permalink":"https://lylgjiavg.github.io/2019/06/30/ji-yu-teng-xun-yun-de-cos-cun-chu-jing-tai-zi-yuan/","excerpt":"","text":"对象存储 COS 简介 对象存储（Cloud Object Storage，COS）是由腾讯云推出的无目录层次结构、无数据格式限制，可容纳海量数据且支持 HTTP/HTTPS 协议访问的分布式存储服务。腾讯云 COS 的存储桶空间无容量上限，无需分区.管理，适用于 CDN 数据分发、数据万象处理或大数据计算与分析的数据湖等多种场景。COS 提供网页端管理界面、多种主流开发语言的 SDK、API 以及命令行和图形化工具，并且兼容 S3 的 API 接口，方便用户直接使用社区工具和插件。 COS作用可以利用对象存储（Cloud Object Storage，COS）来管理我们的博客静态资源,如图片、音乐、以及html、css、js等。个人主要利用COS来管理图片、音乐文件,因为自己博客是发布在GitHub上,所以访问速度受限,而把这些静态文件存储在COS服务上则可以加快博客的加载速度. 利用腾讯云的COS管理静态资源步骤： 1.注册腾讯云账户&nbsp;&nbsp;&nbsp;&nbsp;注册腾讯云并使用COS服务是完全免费的,其中,注册地址为:腾讯云. 2.申请COS服务&nbsp;&nbsp;&nbsp;&nbsp;申请COS服务地址为:COS申请 3.创建存储桶&nbsp;&nbsp;&nbsp;&nbsp;在进入步骤2网址后点击立即使用(个人开发不用购买资源包,使用免费的可以).然后创建储存桶,如下图所示.必填项为:名称注意:访问权限为:公有读私有写(如是默认的私有读写,则博客无法引用静态资源) 4.在存储桶创建文件夹并上传文件 5.进行基础配置点击基础配置项把静态网站的开关使处于开的状态.其中,索引文件不用在意,点击保存. 6.通过COS服务访问静态文件点击已上传的静态资源的详情项,便进入静态资源的信息页面,此时就可以Copy对象地址属性值,引用到你的博客中,完成显示. 附加:腾讯云COS官方应用场景 ####1.应用数据存储 无论是手机 APP、网站，或 HTML5 页面，对象存储可根据应用程序类型提供各语言 SDK，实现无缝接入。当业务爆发、用户产生内容（UGC）突增时，对象存储将根据请求和流量的需求自动扩展，从容应对业务突发访问状况。由于 UGC 通常具有时间维度级的访问特征，对象存储可将数据冷热分层，热数据使用标准存储，冷数据使用低频存储。配合生命周期规则配置，转换存储类别，有效降低存储成本。 ####2.数据处理 对于用户传入 COS 的数据，COS 可结合腾讯云多种数据处理类产品对其进行编辑、处理和审核操作，针对图片数据，用户可结合 数据万象 对其进行裁剪、缩放、转码、锐化、添加水印等处理操作，还可以进行鉴黄、鉴政、鉴暴恐等内容审核；针对视频数据，用户可使用视频处理对其进行转码、水印、截帧等处理；针对文档数据，用户可利用数据万象生成文档的图片或 HTML 预览，并可对预览图添加水印。 ####3.内容分发 网站服务通常会在动态网页中，根据一定规则将经常变动和长期不变的资源区分开，静态资源就是指长期不变的非结构化数据资源。标准存储提供了静态资源的存储和分发能力，减轻资源服务器的压力，并利用无限容量、高频读写的特性，为静态资源提供可扩展和可靠的存储。用户可以将网站中的静态内容（包括音视频、图片等文件）全部托管在标准存储中，并利用腾讯云 CDN 分发内容。结合腾讯云 CDN 全球加速节点的能力，可以将热点文件提前下发至边缘节点，降低访问延迟。 ####4.大数据分析 无论用户存储的是医疗或财务方面的数据还是照片和音视频之类的多媒体文件，COS 都可以作为数据源进行大数据分析。对象存储支持存储 EB 级别非结构化数据，高可用、高可靠、高安全和可扩展性，结合使用腾讯云大数据套件，快速构建和部署分析应用程序。在高性能计算需求完成后，可以将数据转换为归档存储，降低服务使用成本，以便长期存储数据。 ####5.容灾及备份 用户放在对象存储上的数据可以通过跨区域复制功能同时存储在多个指定区域，保证在某些意外丢失部分数据的情况下仍能通过冗余数据来查找并恢复完整数据，同时，因为多份数据存放在不同的地区，因此能避免一个地区的存储受到不可抗逆灾难时会造成的损失，从而达到多冗余备份和异地容灾的效果，保证数据的持久性和稳定性，为重要数据加上多重保险。","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://lylgjiavg.github.io/categories/博客搭建/"}],"tags":[{"name":"COS","slug":"COS","permalink":"https://lylgjiavg.github.io/tags/COS/"}]},{"title":"COS图片文件访问","slug":"测试COS静态资源","date":"2019-06-30T01:35:36.000Z","updated":"2019-06-30T04:38:37.252Z","comments":true,"path":"2019/06/30/ce-shi-cos-jing-tai-zi-yuan/","link":"","permalink":"https://lylgjiavg.github.io/2019/06/30/ce-shi-cos-jing-tai-zi-yuan/","excerpt":"","text":"测试COS Ending","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://lylgjiavg.github.io/categories/博客搭建/"}],"tags":[{"name":"COS图片文件访问","slug":"COS图片文件访问","permalink":"https://lylgjiavg.github.io/tags/COS图片文件访问/"}]},{"title":"代码段测试","slug":"代码段测试","date":"2019-06-30T01:35:36.000Z","updated":"2019-07-01T02:28:57.551Z","comments":true,"path":"2019/06/30/dai-ma-duan-ce-shi/","link":"","permalink":"https://lylgjiavg.github.io/2019/06/30/dai-ma-duan-ce-shi/","excerpt":"","text":"public class CmsPage { /** * 页面名称、别名、访问地址、类型（静态/动态）、页面模版、状态 */ //站点ID private String siteId; //页面ID @Id private String pageId; //页面名称 private String pageName; //别名 private String pageAliase; //访问地址 private String pageWebPath; //参数 private String pageParameter; //物理路径 private String pagePhysicalPath; //类型（静态/动态） private String pageType; //页面模版 private String pageTemplate; //页面静态化内容 private String pageHtml; //状态 private String pageStatus; //创建时间 private Date pageCreateTime; //模版id private String templateId; //参数列表 private List&lt;CmsPageParam> pageParams; //模版文件Id // private String templateFileId; //静态文件Id private String htmlFileId; //数据Url private String dataUrl; }","categories":[{"name":"测试","slug":"测试","permalink":"https://lylgjiavg.github.io/categories/测试/"}],"tags":[{"name":"测试","slug":"测试","permalink":"https://lylgjiavg.github.io/tags/测试/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-06-29T12:51:02.577Z","updated":"2019-06-29T12:51:02.577Z","comments":true,"path":"2019/06/29/hello-world/","link":"","permalink":"https://lylgjiavg.github.io/2019/06/29/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}