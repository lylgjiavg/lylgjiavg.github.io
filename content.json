{"meta":{"title":"Jiavg","subtitle":"lylg-JLC","description":"个人技术总结","author":"Jiavg","url":"https://lylgjiavg.github.io","root":"/"},"pages":[{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2019-06-29T15:25:35.750Z","comments":true,"path":"about/index.html","permalink":"https://lylgjiavg.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-09-30T09:25:30.000Z","updated":"2019-06-29T15:24:29.993Z","comments":true,"path":"categories/index.html","permalink":"https://lylgjiavg.github.io/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2018-12-12T13:25:30.000Z","updated":"2019-06-29T15:26:00.186Z","comments":true,"path":"friends/index.html","permalink":"https://lylgjiavg.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-30T10:23:38.000Z","updated":"2019-06-29T15:25:03.807Z","comments":true,"path":"tags/index.html","permalink":"https://lylgjiavg.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Docker基本使用","slug":"Docker","date":"2019-08-17T12:09:32.000Z","updated":"2019-08-17T16:04:53.304Z","comments":true,"path":"2019/08/17/docker/","link":"","permalink":"https://lylgjiavg.github.io/2019/08/17/docker/","excerpt":"","text":"Docker描述 Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到 任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。Docker安装进入yum目录 [root@bogon yum.repos.d]cd /etc/yum.repos.d/ 下载repo [root@bogon yum.repos.d]# wget https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo --2019-08-17 21:23:14-- https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo 正在解析主机 mirrors.tuna.tsinghua.edu.cn (mirrors.tuna.tsinghua.edu.cn)... 101.6.8.193, 2402:f000:1:408:8100::1 正在连接 mirrors.tuna.tsinghua.edu.cn (mirrors.tuna.tsinghua.edu.cn)|101.6.8.193|:443... 已连接。 已发出 HTTP 请求，正在等待回应... 200 OK 长度：2424 (2.4K) [application/octet-stream] 正在保存至: “docker-ce.repo” 100%[==========================================================================================================>] 2,424 --.-K/s 用时 0s 2019-08-17 21:23:14 (262 MB/s) - 已保存 “docker-ce.repo” [2424/2424]) 验证docker-ce是否安装成功 [root@bogon yum.repos.d]# ls CentOS-Base.repo CentOS-Debuginfo.repo CentOS-Media.repo CentOS-Vault.repo CentOS-CR.repo CentOS-fasttrack.repo CentOS-Sources.repo docker-ce.repo [root@bogon yum.repos.d]# yum repolist 已加载插件：fastestmirror, langpacks Loading mirror speeds from cached hostfile * base: mirrors.njupt.edu.cn * extras: mirrors.cn99.com * updates: mirrors.cn99.com 源标识 源名称 状态 base/7/x86_64 CentOS-7 - Base 10,019 docker-ce-stable/x86_64 Docker CE Stable - x86_64 52 extras/7/x86_64 CentOS-7 - Extras 435 updates/7/x86_64 CentOS-7 - Updates 2,500 repolist: 13,006 [root@bogon yum.repos.d]# docker --version Docker version 19.03.1, build 74b1e89 配置Docker加速器Json[root@bogon yum.repos.d]# mkdir /etc/docker/ [root@bogon yum.repos.d]# vi /etc/docker/daemon.json 在daemon.json 中添加 { &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;] } 测试Docker创建一个httpd服务获得busybox镜像 [root@bogon yum.repos.d]# docker image pull busybox 利用busybox创建一个容器 [root@bogon yum.repos.d]# docker container run --name myhttpd -it busybox 创建httpd工作目录及index.html / # mkdir /data/html -p / # vi /data/html/index.html 在index.html添加&quot;Hello Docker!&quot; 此时此进程处于阻塞状态,然后再启动另一个Shell进程 使用docker inspect myhttpd命令查看myhttpd容器的状态信息 [root@bogon ~]# docker inspect myhttpd [ { ..., ..., &quot;NetworkSettings&quot;: { ..., ... &quot;Networks&quot;: { &quot;bridge&quot;: { &quot;IPAMConfig&quot;: null, &quot;Links&quot;: null, &quot;Aliases&quot;: null, &quot;NetworkID&quot;: &quot;c28b3cad37536a90abf27043b6b2caa931bcd31ec79b0785d92ee00236a8f575&quot;, &quot;EndpointID&quot;: &quot;7dedddc84a36d48c4d6d78773cb571179bd455704cb5c341e6fa43764a2dac0d&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot;, &quot;IPAddress&quot;: &quot;172.17.0.4&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:04&quot;, &quot;DriverOpts&quot;: null } } } } ] 在NetworkSettings下的IPAddress可以获得myhttpd的容器虚拟地址为172.17.0.4 此时使用curl命令来验证httpd服务是否进行 [root@bogon ~]# curl 172.17.0.4 Hello Docker! 可以观察到myhttpd容器内的httpd服务正常运行附:Docker生命周期","categories":[{"name":"容器引擎","slug":"容器引擎","permalink":"https://lylgjiavg.github.io/categories/容器引擎/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://lylgjiavg.github.io/tags/Docker/"},{"name":"container","slug":"container","permalink":"https://lylgjiavg.github.io/tags/container/"}]},{"title":"ArrayList","slug":"ArrayList","date":"2019-08-14T14:28:50.000Z","updated":"2019-08-14T14:57:40.566Z","comments":true,"path":"2019/08/14/arraylist/","link":"","permalink":"https://lylgjiavg.github.io/2019/08/14/arraylist/","excerpt":"","text":"ArrayList类继承关系 IDEA使用Ctrl+Shift+Alt+N快捷键查找此类 ArrayList类继承关系如下图所示: ![ArrayList继承关系图](https://i.imgur.com/nTyDgMV.jpg)Iterable接口 Implementing this interface allows an object to be the target of the “for-each loop” statement. 即:实现这个接口允许对象成为“for-each循环”语句的目标。 而java.util.Collection接口继承java.lang.Iterable，故标准类库中的任何集合都可以使用for-each循环。 为什么一定要去实现Iterable这个接口呢？ 为什么不直接实现Iterator接口呢？看一下JDK中的集合类，比如List一族或者Set一族，都是继承了Iterable接口，但并不直接继承Iterator接口。仔细想一下这么做是有道理的。因为Iterator接口的核心方法next()或者hasNext()是依赖于迭代器的当前迭代位置的。如果Collection直接继承Iterator接口，势必导致集合对象中包含当前迭代位置的数据(指针)。当集合在不同方法间被传递时，由于当前迭代位置不可预置，那么next()方法的结果会变成不可预知。除非再为Iterator接口添加一个reset()方法，用来重置当前迭代位置。但即时这样，Collection也只能同时存在一个当前迭代位置。而Iterable则不然，每次调用都会返回一个从头开始计数的迭代器。多个迭代器是互不干扰的。","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://lylgjiavg.github.io/categories/数据结构和算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lylgjiavg.github.io/tags/数据结构/"}]},{"title":"插入排序","slug":"插入排序-递归+二分查找","date":"2019-07-21T01:58:02.000Z","updated":"2019-07-21T02:09:53.477Z","comments":true,"path":"2019/07/21/cha-ru-pai-xu-di-gui-er-fen-cha-zhao/","link":"","permalink":"https://lylgjiavg.github.io/2019/07/21/cha-ru-pai-xu-di-gui-er-fen-cha-zhao/","excerpt":"","text":"题目：leetcode(912): 给定一个整数数组 nums，将该数组升序排列。 示例 1： 输入：[5,2,3,1] 输出：[1,2,3,5] 示例 2： 输入：[5,1,1,2,0,0] 输出：[0,0,1,1,2,5] 提示： 1 &lt;= A.length &lt;= 10000 -50000 &lt;= A[i] &lt;= 50000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sort-an-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路: (稍后总结) 具体代码:class Solution { public int[] sortArray(int[] nums) { if(nums == null || nums.length == 1){ return nums; } for(int currentInsetIndex = 1; currentInsetIndex &lt; nums.length; currentInsetIndex++){ // currentInset:当前进行插入的数字 int currentInset = nums[currentInsetIndex]; // 当前进行比较的下标 int currentCompareIndex = currentInsetIndex - 1; // 二分查找到正确位置 int index = Solution.binarySearch(nums, 0, currentCompareIndex, currentInset); // 在正确位置进行插入 Solution.insertNum(nums, 0, currentInsetIndex, index); } return nums; } /** * 二分查找数值在已排序数组中正确的下标 * @param array 进行查找的数组 * @param lower 查找下界 * @param up 查找上界 * @param num 查找数字 * @return 下标 */ public static int binarySearch(int[] array, int lower, int up, int num){ int lowerSearch = lower; int upSearch = up; int middle = (upSearch - lowerSearch)/2 + lowerSearch; while(lowerSearch &lt;= upSearch){ if(array[middle] > num){ upSearch = middle - 1; }else{ lowerSearch = middle + 1; } middle = (upSearch - lowerSearch)/2 + lowerSearch; } return middle; } /** * 插入值到数组中(数组范围内的一个数插入到本数组的另一个位置) * @param array 进行插入的数组 * @param lower 插入范围下界 * @param up 插入范围上界(也是要进行插入的值) * @param index 插入下标 */ public static void insertNum(int[] array, int lower, int up, int index){ // unlawfulness if(up &lt;= index &amp;&amp; index &lt; lower){ return; } // save a value of insert int num = array[up]; // move inserted value of last to last for (int i = up; i > index &amp;&amp; i > lower; i--){ array[i] = array[i-1]; } // insert value array[index] = num; } } 运行结果:执行结果： 通过 显示详情 执行用时 : 314 ms, 在所有 Java 提交中击败了8.58%的用户 内存消耗 : 52.1 MB, 在所有 Java 提交中击败了100.00%的用户 结果分析: 本来对这个算法寄予了很大期望: 1.利用二分查找法解决了进行线性查找而需要的线性时间,进而把查找时间压缩到了lg(n). 2.利用迭代替换掉递归,进而解决了在数组长度过大时出现的java.lang.StackOverflowError 对于第一次用算法结合的方式进行排序冷静分析后: 1.对于内存消耗还是很好理解,原址排序. 2.对于执行用时,虽然用二分查找法代替掉了线性查找,但还是改变不了算法本身是插入排序,而对于插入排序最忌惮的就是数组长度.","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://lylgjiavg.github.io/categories/数据结构和算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://lylgjiavg.github.io/tags/LeetCode/"},{"name":"算法导论","slug":"算法导论","permalink":"https://lylgjiavg.github.io/tags/算法导论/"}]},{"title":"插入排序(递归实现)","slug":"插入排序-递归实现","date":"2019-07-20T02:18:26.000Z","updated":"2019-07-20T02:47:08.048Z","comments":true,"path":"2019/07/20/cha-ru-pai-xu-di-gui-shi-xian/","link":"","permalink":"https://lylgjiavg.github.io/2019/07/20/cha-ru-pai-xu-di-gui-shi-xian/","excerpt":"","text":"题目：leetcode(912): 给定一个整数数组 nums，将该数组升序排列。 示例 1： 输入：[5,2,3,1] 输出：[1,2,3,5] 示例 2： 输入：[5,1,1,2,0,0] 输出：[0,0,1,1,2,5] 提示： 1 &lt;= A.length &lt;= 10000 -50000 &lt;= A[i] &lt;= 50000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sort-an-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路: (稍后总结) 具体代码: public static void insertionSort(int[] array, int lower, int up){ // 合并 if(lower &lt; up){ // 分解 insertionSort(array, lower, up - 1); // 解决 int index = lineSearch(array, lower, up -1, array[up]); insertNum(array, lower, up, index); } } /** * 线性查找数值在已排序数组中正确的下标 * @param array 进行查找的数组 * @param lower 查找下界 * @param up 查找上界 * @param num 查找数字 * @return 下标 */ public static int lineSearch(int[] array, int lower, int up, int num){ for(int i = up; i >= lower; i--){ if(array[i] &lt; num){ return i + 1; } } return lower; } /** * 插入值到数组中(数组范围内的一个数插入到本数组的另一个位置) * @param array 进行插入的数组 * @param lower 插入范围下界 * @param up 插入范围上界(也是要进行插入的值) * @param index 插入下标 */ public static void insertNum(int[] array, int lower, int up, int index){ // unlawfulness if(up &lt;= index &amp;&amp; index &lt; lower){ return; } // save a value of insert int num = array[up]; // move inserted value of last to last for (int i = up; i > index &amp;&amp; i > lower; i--){ array[i] = array[i-1]; } // insert value array[index] = num; } 运行结果:执行结果： 超出时间限制 显示详情 最后执行的输入： [5864,-12333,4151,-6239,-10306,10866,-7013,13195,-8855,1150,-560,3227,10387,-2329,5169,-19527...] 显示详情: 提交记录 9 / 10 个通过测试用例 状态：超出时间限制 结果分析: 对于这个结果很诧异也在情理之中,对于算法本身没有什么问题,LeetCode应该是检测到消耗的资源和时间太多才会显示这个结果(9 / 10 个通过测试用例,1 &lt;= A.length &lt;= 10000,-50000 &lt;= A[i] &lt;= 50000).而本身自己也做了一个测试,测试代码如下: public static void main(String[] args) { int[] array = new int[10000]; Random rand = new Random(); for (int i = 0; i &lt; 10000; i++){ array[i] = rand.nextInt(10000) - 5000; } insertionSort(array, 0, array.length - 1); System.out.printf(array.toString()); } 而对于结果则是没有什么问题的.我在接下来,则会用二分查找法进行查找要插入的下标,大大减少查询所用时间,相信将不会出现超出时间限制这个结果. 附:--------------------- 插入排序的特点: 1.对于少量元素的排序,他是一个有效的算法 2.原址排序 递归和迭代特点: 使用场景： 需要重复地多次地计算相同的问题，一般会用到递归和循环。 递归： 概念：内部调用函数本身。 使用前提： 在使用递归的时候，必须有一个明确的递归结束条件，称之为递归出口。 使用递归，必须预期收敛。 迭代： 通过设置初始条件和结束条件，在一个范围内重复计算。 代码的可读性不如递归，但是效率更高。 递归的优点： 1. 代码简洁； 2. 在树的前序，中序，后序的遍历算法中，递归的实现比循环简单很多。 递归的缺点： 1. 时间和空间的消耗比较大。 每一个线程都会有一个私有的栈mixed stack，存储java方法的桢栈和native方法的桢栈。每一次方法的调用都涉及到一个桢栈的入栈到出栈。同时，会涉及到分配内存空间，保存参数，返回地址和临时变量，而且往栈里压入数据和弹出都需要时间。 2. 递归会出现重复计算。 递归的本质是把一个问题分解为多个问题，如果多个问题存在重复计算，有时候这个情况会随着n成指数增长。比如斐波那契的递归就是一个例子。 3. 递归还有栈溢出的问题，每个线程的栈容量多少有限的。 如果栈内存没有可用空间存储方法桢栈（包括局部变量表，操作数栈，返回地址，动态链接），jvm会抛出java.lang.StackOverFlowError. 栈的内存远远小于堆内存，-Xss选项设置栈内存大小，-Xms设置堆开始的大小，-Xmx堆最大值.(ps：如果是堆内存没有可用空间存储生成对象，jvm会抛出java.lang.OutOfMemoryError.) 迭代的速度快，那么递归存在的意义呢？ 理论上来说，所有的递归函数都可以转换为迭代函数，反之亦然。但是一般来说，代价比较高。 实际上来说，迭代都可以转换为递归，但是递归不一定能转换为迭代。 --------------------- 作者：YY_worhol 来源：CSDN 原文：https://blog.csdn.net/YY_worhol/article/details/83617109 版权声明：本文为博主原创文章，转载请附上博文链接！","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://lylgjiavg.github.io/categories/数据结构和算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://lylgjiavg.github.io/tags/LeetCode/"},{"name":"算法导论","slug":"算法导论","permalink":"https://lylgjiavg.github.io/tags/算法导论/"}]},{"title":"归并排序","slug":"归并排序","date":"2019-07-19T13:16:15.000Z","updated":"2019-07-19T13:28:05.914Z","comments":true,"path":"2019/07/19/gui-bing-pai-xu/","link":"","permalink":"https://lylgjiavg.github.io/2019/07/19/gui-bing-pai-xu/","excerpt":"","text":"题目：leetcode(912): 给定一个整数数组 nums，将该数组升序排列。 示例 1： 输入：[5,2,3,1] 输出：[1,2,3,5] 示例 2： 输入：[5,1,1,2,0,0] 输出：[0,0,1,1,2,5] 提示： 1 &lt;= A.length &lt;= 10000 -50000 &lt;= A[i] &lt;= 50000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sort-an-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路: (稍后总结：TODO) 具体代码:class Solution { public int[] sortArray(int[] nums) { Solution.mergeSort(nums, 0, nums.length - 1); return nums; } public static void mergeSort(int arr[], int lower, int up){ if(lower &lt; up){ int middleLeft = (up - lower)/2 + lower; int middleRight = middleLeft + 1; mergeSort(arr, lower, middleLeft); mergeSort(arr, middleRight, up); merge(arr, lower, middleLeft, up); } } public static void merge(int arr[], int lower, int middle, int up){ // lower ~ middle int leftLength = middle - lower + 1; // middle+1 ~ up int rightLength = up - middle; // +1是为了在最底层存放一个最大的数字,可以使本数组元素抽取完毕后不断把另一个数组元素抽取 int[] leftArr = new int[leftLength + 1]; int[] rightArr = new int[rightLength + 1]; for(int i = 0; i &lt; leftLength; i++){ leftArr[i] = arr[lower + i]; } for(int i = 0; i &lt; rightLength; i++){ rightArr[i] = arr[middle + i + 1]; } leftArr[leftLength] = Integer.MAX_VALUE; rightArr[rightLength] = Integer.MAX_VALUE; int l = 0; int r = 0; for(int j = 0; j &lt; (up - lower + 1); j++){ if(leftArr[l] &lt; rightArr[r]){ arr[lower + j] = leftArr[l]; l++; }else{ arr[lower + j] = rightArr[r]; r++; } } } } 运行结果:执行结果：通过 显示详情 执行用时 : 17 ms, 在所有 Java 提交中击败了48.93%的用户 内存消耗 : 50.4 MB, 在所有 Java 提交中击败了100.00%的用户 结果分析:由归并排序的特点: 1.采用了分治思想，该算法最坏情况运行时间比插入排序（增量方法）要少得多。 2.归并排序将原问题分解成几个规模较小的但类似于原问题的子问题，递归的求这些子问题，然后合并这些子问题的解来建立原问题的解（这就是分治思想的特点）。 分析可得: （稍后分析：TODO）","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://lylgjiavg.github.io/categories/数据结构和算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://lylgjiavg.github.io/tags/LeetCode/"},{"name":"算法导论","slug":"算法导论","permalink":"https://lylgjiavg.github.io/tags/算法导论/"}]},{"title":"插入排序","slug":"插入排序","date":"2019-07-19T02:17:55.000Z","updated":"2019-07-19T07:25:49.001Z","comments":true,"path":"2019/07/19/cha-ru-pai-xu/","link":"","permalink":"https://lylgjiavg.github.io/2019/07/19/cha-ru-pai-xu/","excerpt":"","text":"题目：leetcode(912): 给定一个整数数组 nums，将该数组升序排列。 示例 1： 输入：[5,2,3,1] 输出：[1,2,3,5] 示例 2： 输入：[5,1,1,2,0,0] 输出：[0,0,1,1,2,5] 提示： 1 &lt;= A.length &lt;= 10000 -50000 &lt;= A[i] &lt;= 50000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sort-an-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路: (稍后总结) 具体代码:public int[] sortArray(int[] nums) { if(nums == null || nums.length == 1){ return nums; } for(int currentInsetIndex = 1; currentInsetIndex &lt; nums.length; currentInsetIndex++){ int currentInset = nums[currentInsetIndex]; int currentCompareIndex = currentInsetIndex - 1; while(currentCompareIndex >= 0 &amp;&amp; nums[currentCompareIndex] > currentInset){ nums[currentCompareIndex + 1] = nums[currentCompareIndex]; currentCompareIndex--; } nums[currentCompareIndex + 1] = currentInset; } return nums; } 运行结果:执行结果：通过 显示详情 执行用时 : 407 ms, 在所有 Java 提交中击败了5.04%的用户 内存消耗 : 51.5 MB, 在所有 Java 提交中击败了100.00%的用户 结果分析:由插入排序的特点: 1.对于少量元素的排序,他是一个有效的算法 2.原址排序 分析可得: 1.由于每次插入都需要与前面已经排序好的进行比较,最坏情况下需要比较n次(n为每次插入已排序好的数组元素值),故对于10000这个数量的数组大小,插入排序表现得情况很差. 2.由于插入排序进行原址排序,故内存消耗表现非常完美.","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://lylgjiavg.github.io/categories/数据结构和算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://lylgjiavg.github.io/tags/LeetCode/"},{"name":"算法导论","slug":"算法导论","permalink":"https://lylgjiavg.github.io/tags/算法导论/"}]},{"title":"两两交换链表中的节点(Swap Nodes in Pairs)","slug":"两两交换链表中的节点-Swap-Nodes-in-Pairs","date":"2019-06-30T12:14:54.000Z","updated":"2019-07-04T10:08:10.195Z","comments":true,"path":"2019/06/30/liang-liang-jiao-huan-lian-biao-zhong-de-jie-dian-swap-nodes-in-pairs/","link":"","permalink":"https://lylgjiavg.github.io/2019/06/30/liang-liang-jiao-huan-lian-biao-zhong-de-jie-dian-swap-nodes-in-pairs/","excerpt":"","text":"题目描述:给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。示例: 给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.链表类: class ListNode{ int val; ListNode next; ListNode(int x){ val = x; } } 解题思路:注意:在进行交换时:要保证链表的各个部分的引用均不被丢弃. (一般情况) 情况一(绿色线段表示):当两两交换的链表处于链表的第一和第二位置步骤一:保存奇数节点(节点3)的引用;步骤二:保存偶数节点(节点4)的引用;是步骤四的前提,如果不保存,步骤三过后节点4的引用将被丢弃.(步骤三和步骤四不可调换,否则需要额外的内存(引用)来保存节点5的引用信息)步骤三:节点3.next=节点5;步骤四:节点4.next=节点3; (特殊情况)情况二(黑色线段表示):当两两交换的链表不是处于链表的第一和第二位置步骤一:保存奇数节点(节点1)的引用;步骤二:保存偶数节点(节点2)的引用;与情况一不同的是:保存偶数节点的引用为交换后链表的头引用,而不能是情况一的中间变量,否则中间变量在进行下一重循环而重新赋值后,交换后的链表头的引用将被丢弃.(步骤三和步骤四不可调换,否则需要额外的内存(引用)来保存节点3的引用信息)步骤三:节点1.next=节点3;步骤四:节点2.next=节点1; 具体代码1:public ListNode swapPairs(ListNode head) { // 非空验证 if(head == null || head.next == null){ return head; } // 交换结果链表头引用 ListNode reverse = head; // 当前交换位置 ListNode current = head; // 两两交换的前一链表的引用(使已交换的链表指向刚交换好的链表节点) ListNode forSwap = null; while(current != null){ // 如果总链表的节点数为奇数,则最后那个节点就没必要进行交换 if(current.next != null){ /********步骤一********/ ListNode odd = current; /********步骤二********/ // 情况一 if(forSwap != null){ forSwap.next = odd.next; } // 情况二 if(current == head){ reverse = odd.next; } /********步骤三********/ odd.next = odd.next.next; /********步骤四********/ if(forSwap != null) { // 情况一 forSwap.next.next = odd; }else{ // 情况二 reverse.next = odd; } // 更新要交换的下两个节点信息 current = odd.next; forSwap = odd; }else { return reverse; } } return reverse; } 在LeetCode运行的结果:成功 显示详情 执行用时 : 1 ms, 在Swap Nodes in Pairs的Java提交中击败了94.04% 的用户 内存消耗 : 34.1 MB, 在Swap Nodes in Pairs的Java提交中击败了88.92% 的用户 来自 &lt;https://leetcode-cn.com/problems/swap-nodes-in-pairs/submissions/&gt; 具体代码2:(思路和代码1相同,只不过两两交换的第二个节点用了额外的变量进行保存,但运行情况却比较代码1好一点,我不明白的是明明引用少了一个,为什么内存消耗为什么反而减小?初学算法,请多多指教) public ListNode swapPairs(ListNode head) { // 非空验证 if(head == null || head.next == null){ return head; } ListNode reverse = head; ListNode current = head; ListNode forSwap = null; while(current != null){ if(current.next != null){ /********步骤一********/ ListNode odd = current; /********步骤二********/ ListNode even = odd.next; if(current == head){ reverse = even; } /********步骤三********/ odd.next = even.next; /********步骤四********/ even.next = odd; // 链接到已交换的链表后 if(forSwap != null){ forSwap.next = even; } current = odd.next; forSwap = odd; }else { return reverse; } } return reverse; } 在LeetCode运行的结果:成功 显示详情 执行用时 : 1 ms, 在Swap Nodes in Pairs的Java提交中击败了94.04% 的用户 内存消耗 : 33.9 MB, 在Swap Nodes in Pairs的Java提交中击败了90.90% 的用户 来自 [LeetCode](https://leetcode-cn.com/problems/swap-nodes-in-pairs/submissions/) 附:不知道LeetCode运行时会不会受到当时服务器的速度影响,还是LeetCode针对提交的代码有一套自己对时间复杂度和空间复杂度有一套自己的算法,总感觉提交后有些许不同.​​","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://lylgjiavg.github.io/categories/数据结构和算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://lylgjiavg.github.io/tags/LeetCode/"}]},{"title":"基于腾讯云的COS存储静态资源","slug":"基于腾讯云的COS存储静态资源","date":"2019-06-30T02:03:17.000Z","updated":"2019-07-04T10:10:10.853Z","comments":true,"path":"2019/06/30/ji-yu-teng-xun-yun-de-cos-cun-chu-jing-tai-zi-yuan/","link":"","permalink":"https://lylgjiavg.github.io/2019/06/30/ji-yu-teng-xun-yun-de-cos-cun-chu-jing-tai-zi-yuan/","excerpt":"","text":"对象存储 COS 简介 对象存储（Cloud Object Storage，COS）是由腾讯云推出的无目录层次结构、无数据格式限制，可容纳海量数据且支持 HTTP/HTTPS 协议访问的分布式存储服务。腾讯云 COS 的存储桶空间无容量上限，无需分区.管理，适用于 CDN 数据分发、数据万象处理或大数据计算与分析的数据湖等多种场景。COS 提供网页端管理界面、多种主流开发语言的 SDK、API 以及命令行和图形化工具，并且兼容 S3 的 API 接口，方便用户直接使用社区工具和插件。 COS作用可以利用对象存储（Cloud Object Storage，COS）来管理我们的博客静态资源,如图片、音乐、以及html、css、js等。个人主要利用COS来管理图片、音乐文件,因为自己博客是发布在GitHub上,所以访问速度受限,而把这些静态文件存储在COS服务上则可以加快博客的加载速度. 利用腾讯云的COS管理静态资源步骤： 1.注册腾讯云账户&nbsp;&nbsp;&nbsp;&nbsp;注册腾讯云并使用COS服务是完全免费的,其中,注册地址为:腾讯云. 2.申请COS服务&nbsp;&nbsp;&nbsp;&nbsp;申请COS服务地址为:COS申请 3.创建存储桶&nbsp;&nbsp;&nbsp;&nbsp;在进入步骤2网址后点击立即使用(个人开发不用购买资源包,使用免费的可以).然后创建储存桶,如下图所示.必填项为:名称注意:访问权限为:公有读私有写(如是默认的私有读写,则博客无法引用静态资源) 4.在存储桶创建文件夹并上传文件 5.进行基础配置点击基础配置项把静态网站的开关使处于开的状态.其中,索引文件不用在意,点击保存. 6.通过COS服务访问静态文件点击已上传的静态资源的详情项,便进入静态资源的信息页面,此时就可以Copy对象地址属性值,引用到你的博客中,完成显示. 附加:腾讯云COS官方应用场景 ####1.应用数据存储 无论是手机 APP、网站，或 HTML5 页面，对象存储可根据应用程序类型提供各语言 SDK，实现无缝接入。当业务爆发、用户产生内容（UGC）突增时，对象存储将根据请求和流量的需求自动扩展，从容应对业务突发访问状况。由于 UGC 通常具有时间维度级的访问特征，对象存储可将数据冷热分层，热数据使用标准存储，冷数据使用低频存储。配合生命周期规则配置，转换存储类别，有效降低存储成本。 ####2.数据处理 对于用户传入 COS 的数据，COS 可结合腾讯云多种数据处理类产品对其进行编辑、处理和审核操作，针对图片数据，用户可结合 数据万象 对其进行裁剪、缩放、转码、锐化、添加水印等处理操作，还可以进行鉴黄、鉴政、鉴暴恐等内容审核；针对视频数据，用户可使用视频处理对其进行转码、水印、截帧等处理；针对文档数据，用户可利用数据万象生成文档的图片或 HTML 预览，并可对预览图添加水印。 ####3.内容分发 网站服务通常会在动态网页中，根据一定规则将经常变动和长期不变的资源区分开，静态资源就是指长期不变的非结构化数据资源。标准存储提供了静态资源的存储和分发能力，减轻资源服务器的压力，并利用无限容量、高频读写的特性，为静态资源提供可扩展和可靠的存储。用户可以将网站中的静态内容（包括音视频、图片等文件）全部托管在标准存储中，并利用腾讯云 CDN 分发内容。结合腾讯云 CDN 全球加速节点的能力，可以将热点文件提前下发至边缘节点，降低访问延迟。 ####4.大数据分析 无论用户存储的是医疗或财务方面的数据还是照片和音视频之类的多媒体文件，COS 都可以作为数据源进行大数据分析。对象存储支持存储 EB 级别非结构化数据，高可用、高可靠、高安全和可扩展性，结合使用腾讯云大数据套件，快速构建和部署分析应用程序。在高性能计算需求完成后，可以将数据转换为归档存储，降低服务使用成本，以便长期存储数据。 ####5.容灾及备份 用户放在对象存储上的数据可以通过跨区域复制功能同时存储在多个指定区域，保证在某些意外丢失部分数据的情况下仍能通过冗余数据来查找并恢复完整数据，同时，因为多份数据存放在不同的地区，因此能避免一个地区的存储受到不可抗逆灾难时会造成的损失，从而达到多冗余备份和异地容灾的效果，保证数据的持久性和稳定性，为重要数据加上多重保险。","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://lylgjiavg.github.io/categories/博客搭建/"}],"tags":[{"name":"COS","slug":"COS","permalink":"https://lylgjiavg.github.io/tags/COS/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-06-29T12:51:02.577Z","updated":"2019-06-29T12:51:02.577Z","comments":true,"path":"2019/06/29/hello-world/","link":"","permalink":"https://lylgjiavg.github.io/2019/06/29/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}